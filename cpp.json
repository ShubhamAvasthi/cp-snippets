{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	
	
	"My Template for Competitive Programming": {
		"prefix": "mytemplate",
		"body": [
			"#include <algorithm>",
			"#include <array>",
			"#include <bitset>",
			"#include <cassert>",
			"#include <cfloat>",
			"#include <chrono>",
			"#include <climits>",
			"#include <cmath>",
			"#include <cstdio>",
			"#include <deque>",
			"#include <iomanip>",
			"#include <iostream>",
			"#include <map>",
			"#include <numeric>",
			"#include <queue>",
			"#include <random>",
			"#include <set>",
			"#include <sstream>",
			"#include <stack>",
			"#include <stdexcept>",
			"#include <unordered_map>",
			"#include <unordered_set>",
			"#include <vector>",
			"using namespace std;",
			"",
			"template <class T1, class T2>",
			"ostream& operator << (ostream& out, const pair <T1, T2> p)",
			"{",
			"\tout << '(' << p.first << ',' << p.second << ')';",
			"\treturn out;",
			"}",
			"",
			"template <class T1, class T2>",
			"istream& operator >> (istream& in, pair<T1, T2> &p)",
			"{",
			"\tin >> p.first >> p.second;",
			"\treturn in;",
			"}",
			"",
			"template <class T>",
			"istream& operator >> (istream& in, vector<T> &v)",
			"{",
			"\tfor (T &x : v)",
			"\t\tin >> x;",
			"\treturn in;",
			"}",
			"",
			"template <class T>",
			"ostream& operator << (ostream& out, const vector<vector<T>> &v)",
			"{",
			"\tfor (const vector<T> &x : v)",
			"\t\tout << x << '\\n';",
			"\treturn out;",
			"}",
			"",
			"template <class T>",
			"ostream& operator << (ostream& out, const vector<T> &v)",
			"{",
			"\tfor (const T &x : v)",
			"\t\tout << x << ' ';",
			"\treturn out;",
			"}",
			"",
			"long long gcd (long long a, long long b)",
			"{",
			"\tif (b > a)",
			"\t\tswap(a, b);",
			"\treturn (b ? gcd(b, a % b) : a);",
			"}",
			"",
			"using ll   = long long;",
			"using pii  = pair<int, int>;",
			"using pll  = pair<long long, long long>;",
			"using tiii = pair<pair<int, int>, int>;",
			"using vi   = vector<int>;",
			"using vl   = vector<long long>;",
			"using vvi  = vector<vector<int>>;",
			"using vvl  = vector<vector<long long>>;",
			"",
			"#define F          first",
			"#define S          second",
			"#define First      first.first",
			"#define Second     first.second",
			"#define Third      second",
			"#define mp         make_pair",
			"#define rep(i,a,b) for (int i = (a); i < (b); i++)",
			"#define per(i,b,a) for (int i = (b); i > (a); i--)",
			"#define all(x)     x.begin(), x.end()",
			"#define ret(x)     return cout << x, 0;",
			"#define throwex    throw runtime_error (\"Found the error.\");",
			"",
			"const int h = 1000000007;",
			"",
			"signed main()",
			"{",
			"\tios::sync_with_stdio(false);",
			"\t#ifdef ONLINE_JUDGE",
			"\tcin.tie(nullptr);",
			"\tcerr.setstate(ios::failbit);",
			"\t#endif",
			"",
			"\t$0",
			"}",
			""
		],
		"description": "Inserts my C++ template for Competitive Programming"
	},


	"Segment Tree": {
		"prefix": "segment-tree",
		"body": [
			"template <class T = long long>",
			"class SegTree",
			"{",
			"private:",
			"\tT default_element_value = 0;",
			"\tvector<T> v, seg_tree;",
			"\tT merge(T x, T y)",
			"\t{",
			"\t\treturn max(x, y);",
			"\t}",
			"\tvoid build(int node, int start, int end)",
			"\t{",
			"\t\tif(start == end)",
			"\t\t\tseg_tree[node] = v[start];",
			"\t\telse",
			"\t\t{",
			"\t\t\tbuild(2*node+1, start, (start+end)/2);",
			"\t\t\tbuild(2*node+2, (start+end)/2+1, end);",
			"\t\t\tseg_tree[node] = merge(seg_tree[2*node+1], seg_tree[2*node+2]);",
			"\t\t}",
			"\t}",
			"\tvoid update(int node, int start, int end, int index, T val)",
			"\t{",
			"\t\tif(start == end)",
			"\t\t{",
			"\t\t\tseg_tree[node] = val;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tif(index<=(start+end)/2)",
			"\t\t\tupdate(2*node+1, start, (start+end)/2, index, val);",
			"\t\telse",
			"\t\t\tupdate(2*node+2, (start+end)/2+1, end, index, val);",
			"\t\tseg_tree[node] = merge(seg_tree[2*node+1], seg_tree[2*node+2]);",
			"\t}",
			"\tT query(int node, int start, int end, int l, int r)",
			"\t{",
			"\t\tif(end<l || start>r)",
			"\t\t\treturn default_element_value;",
			"\t\tif(start>=l && end<=r)",
			"\t\t\treturn seg_tree[node];",
			"\t\treturn merge(",
			"\t\t\tquery(2*node+1, start, (start+end)/2, l, r),",
			"\t\t\tquery(2*node+2, (start+end)/2+1, end, l, r));",
			"\t}",
			"",
			"public:",
			"\tSegTree(int n)",
			"\t{",
			"\t\tv.resize(n, default_element_value); //except its size, v won't be used anymore",
			"\t\tseg_tree.resize(4 * n, default_element_value);",
			"\t}",
			"\tSegTree(vector<T> &arr)",
			"\t{",
			"\t\tv = arr;",
			"\t\tseg_tree.resize(4 * v.size(), default_element_value);",
			"\t\tbuild(0, 0, v.size()-1);",
			"\t}",
			"\tvoid update(int index, T val)",
			"\t{",
			"\t\tupdate(0, 0, v.size()-1, index, val);",
			"\t}",
			"\tT query(int l, int r)",
			"\t{",
			"\t\treturn query(0, 0, v.size()-1, l, r);",
			"\t}",
			"};"
		],
		"description": "My segment tree code"
	},


	"Disjoint Set Union": {
		"prefix": "disjoint_set_union",
		"body": [
			"class DSU",
			"{",
			"private:",
			"\tvector<int> par, size;",
			"\tint distinct_sets_count;",
			"",
			"\tint root(const int x)",
			"\t{",
			"\t\tif(par[x] == x)",
			"\t\t\treturn x;",
			"\t\treturn par[x] = root(par[x]);",
			"\t}",
			"",
			"public:",
			"\tDSU(int n)",
			"\t{",
			"\t\tdistinct_sets_count = n;",
			"\t\tpar.resize(n);",
			"\t\tfor(int i = 0; i < n; i++)",
			"\t\t\tpar[i] = i;",
			"\t\tsize.resize(n, 1);",
			"\t}",
			"",
			"\tvoid connect(int a, int b)",
			"\t{",
			"\t\ta = root(a), b = root(b);",
			"\t\tif(a == b) return;",
			"\t\tif(size[a] < size[b])",
			"\t\t\tswap(a, b);",
			"\t\tsize[a] += size[b];",
			"\t\tpar[b] = a;",
			"\t\tdistinct_sets_count--;",
			"\t}",
			"",
			"\tbool same_component(const int x, const int y)",
			"\t{",
			"\t\treturn root(x) == root(y);",
			"\t}",
			"",
			"\tbool is_leader(const int x)",
			"\t{",
			"\t\treturn root(x) == x;",
			"\t}",
			"",
			"\tint size_of_component(const int x)",
			"\t{",
			"\t\treturn size[root(x)];",
			"\t}",
			"",
			"\tint count() const",
			"\t{",
			"\t\treturn distinct_sets_count;",
			"\t}",
			"};"
		],
		"description": "My Disjoint Set Union class"
	},


	"Euler's Totient function": {
		"prefix": "totient",
		"body": [
			"long long phi(long long n)",
			"{",
			"\tlong long ans = n;",
			"\tfor(long long i = 2; i * i <= n; i++)",
			"\t\tif(n % i == 0)",
			"\t\t{",
			"\t\t\tans -= ans / i;",
			"\t\t\twhile(n % i == 0)",
			"\t\t\t\tn /= i;",
			"\t\t}",
			"\tif(n > 1)",
			"\t\tans -= ans / n;",
			"\treturn ans;",
			"}"
		],
		"description": "My Euler's Totient function code"
	},


	"Manacher's Algorithm": {
		"prefix": "manacher",
		"body": [
			"class Manacher",
			"{",
			"\tpublic:",
			"\tvector<int> d1, d2;",
			"",
			"\tManacher (string s)",
			"\t{",
			"\t\td1.resize(s.size());",
			"\t\td2.resize(s.size() - 1);",
			"\t\tfor (int i = 0, l = -1, r = -1; i < s.size(); i++)",
			"\t\t{",
			"\t\t\tint k = (i > r) ? 0 : min(d1[l + r - i], r - i + 1);",
			"\t\t\twhile (i - k > - 1 and i + k < s.size() and s[i - k] == s[i + k])",
			"\t\t\t\tk++;",
			"\t\t\td1[i] = k;",
			"\t\t\tif (i + d1[i] - 1 > r)",
			"\t\t\t{",
			"\t\t\t\tl = i - d1[i] + 1;",
			"\t\t\t\tr = i + d1[i] - 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor (int i = 0, l = -1, r = -1; i < s.size() - 1; i++)",
			"\t\t{",
			"\t\t\tint k = (i > r - 1) ? 0 : min(d2[l + r - i - 1], r - i);",
			"\t\t\twhile (i - k > - 1 and i + 1 + k < s.size() and s[i - k] == s[i + 1 + k])",
			"\t\t\t\tk++;",
			"\t\t\td2[i] = k;",
			"\t\t\tif (i + d2[i] > r)",
			"\t\t\t{",
			"\t\t\t\tl = i - d2[i] + 1;",
			"\t\t\t\tr = i + d2[i];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"};",
			""
		],
		"description": "My Manacher's Algorithm's code"
	},


	"Lowest Common Ancestor": {
		"prefix": "lowest-common-ancestor",
		"body": [
			"class LCA",
			"{",
			"private:",
			"\tstatic const int max_power_of_2 = 24;",
			"\tvector<int> par, level;",
			"\tarray<vector<int>, max_power_of_2 + 1> sp;",
			"",
			"\tint lift (int x, int d)",
			"\t{",
			"\t\tfor (int i = max_power_of_2; i > -1; i--)",
			"\t\t\tif(d >= 1 << i)",
			"\t\t\t{",
			"\t\t\t\td -= 1 << i;",
			"\t\t\t\tx = sp[i][x];",
			"\t\t\t}",
			"\t\treturn x;",
			"\t}",
			"",
			"\tvoid dfs (int x, int p, int lev, vector<vector<int>> &M)",
			"\t{",
			"\t\tpar[x] = p;",
			"\t\tlevel[x] = lev;",
			"\t\tfor(int y : M[x])",
			"\t\t{",
			"\t\t\tif(par[y] != -1) continue;",
			"\t\t\tdfs(y, x, lev + 1, M);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tLCA (vector<vector<int>> &M)",
			"\t{",
			"\t\tpar.resize(M.size(), -1);",
			"\t\tlevel.resize(M.size());",
			"\t\tfor(vector<int> &x : sp)",
			"\t\t\tx.resize(M.size());",
			"\t\tdfs(0, 0, 0, M);",
			"\t\tsp[0] = par;",
			"\t\tfor (int i = 1; i < max_power_of_2 + 1; i++)",
			"\t\t\tfor (int j = 0; j < M.size(); j++)",
			"\t\t\t\tsp[i][j] = sp[i-1][sp[i-1][j]];",
			"\t}",
			"",
			"\tint dist (int x, int y)",
			"\t{",
			"\t\tif(level[x] < level[y])",
			"\t\t\tswap(x, y);",
			"\t\tint ans = level[x] - level[y];",
			"\t\tx = lift(x, level[x] - level[y]);",
			"\t\tfor (int i = max_power_of_2; i > -1; i--)",
			"\t\t\tif (sp[i][x] != sp[i][y])",
			"\t\t\t{",
			"\t\t\t\tx = sp[i][x];",
			"\t\t\t\ty = sp[i][y];",
			"\t\t\t\tans += 2 * (1 << i);",
			"\t\t\t}",
			"\t\treturn ans + 2 * (x != y);",
			"\t}",
			"};"
		],
		"description": "My Lowest Common Ancestor code"
	},


	"Binary Lifting": {
		"prefix": "binary-lifting",
		"body": [
			"class BinaryLifting",
			"{",
			"private:",
			"\tstatic const int max_power_of_2 = 24;",
			"\tarray<vector<int>, max_power_of_2 + 1> sp;",
			"",
			"\tvoid dfs (int x, int p, int lev, vector<vector<int>> &M)",
			"\t{",
			"\t\tsp[0][x] = p;",
			"\t\tfor(int y : M[x])",
			"\t\t{",
			"\t\t\tif(sp[0][y] != -1) continue;",
			"\t\t\tdfs(y, x, lev + 1, M);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tBinaryLifting (vector<vector<int>> &M)",
			"\t{",
			"\t\tfor(vector<int> &x : sp)",
			"\t\t\tx.resize(M.size(), -1);",
			"\t\tdfs(0, 0, 0, M);",
			"\t\tfor (int i = 1; i <= max_power_of_2; i++)",
			"\t\t\tfor (int j = 0; j < M.size(); j++)",
			"\t\t\t\tsp[i][j] = sp[i-1][sp[i-1][j]];",
			"\t}",
			"",
			"\tint lift (int x, int d)",
			"\t{",
			"\t\tfor (int i = max_power_of_2; i > -1; i--)",
			"\t\t\tif(d >= 1 << i)",
			"\t\t\t{",
			"\t\t\t\td -= 1 << i;",
			"\t\t\t\tx = sp[i][x];",
			"\t\t\t}",
			"\t\treturn x;",
			"\t}",
			"};"
		],
		"description": "My binary lifting code"
	},


	"Time it": {
		"prefix": "time-it",
		"body": [
			"auto start_time = chrono::high_resolution_clock::now();",
			"",
			"auto end_time = chrono::high_resolution_clock::now();",
			"chrono::high_resolution_clock::duration time_duration = end_time - start_time;",
			"",
			"auto h  = chrono::duration_cast<chrono::hours>(time_duration);        time_duration -= h;",
			"auto m  = chrono::duration_cast<chrono::minutes>(time_duration);      time_duration -= m;",
			"auto s  = chrono::duration_cast<chrono::seconds>(time_duration);      time_duration -= s;",
			"auto ms = chrono::duration_cast<chrono::milliseconds>(time_duration); time_duration -= ms;",
			"auto us = chrono::duration_cast<chrono::microseconds>(time_duration); time_duration -= us;",
			"auto ns = chrono::duration_cast<chrono::nanoseconds>(time_duration);",
			"",
			"cerr<<\"Execution Time: \"",
			"<< h.count()  << \" hours \"",
			"<< m.count()  << \" minutes \"",
			"<< s.count()  << \" seconds \"",
			"<< ms.count() << \" milliseconds \"",
			"<< us.count() << \" microseconds \"",
			"<< ns.count() << \" nanoseconds\\n\";"
		],
		"description": "Code to print the execution time of a section of code"
	},


	"Fast Walsh Hadamard Transform": {
		"prefix": "fast-walsh-hadamard-transform",
		"body": [
			"class FWHT",
			"{",
			"private:",
			"\tstatic const int mod = 1000000007;",
			"",
			"\tstatic long long p (long long x, long long y)",
			"\t{",
			"\t\tif (y == 0) return 1;",
			"\t\tlong long z = p (x, y / 2);",
			"\t\tz *= z;",
			"\t\tz %= mod;",
			"\t\treturn (y & 1 ? (z * x) % mod : z);",
			"\t}",
			"",
			"\tstatic long long inv (long long x)",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"",
			"public:",
			"\tstatic void fwht (vector<int> & a, bool invert) {",
			"\t\tint n = a.size();",
			"\t\tfor (int len = 1; 2 * len <= n; len <<= 1) {",
			"\t\t\tfor (int i = 0; i < n; i += 2 * len) {",
			"\t\t\t\tfor (int j = 0; j < len; j++) {",
			"\t\t\t\t\tint u = a[i + j];",
			"\t\t\t\t\tint v = a[i + j + len];",
			"\t\t\t\t\ta[i + j] = u + v < mod ? u + v : u + v - mod;",
			"\t\t\t\t\ta[i + j + len] = u - v >= 0 ? u - v : u - v + mod;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (invert) {",
			"\t\t\tint n_1 = inv(n);",
			"\t\t\tfor (int & x : a)",
			"\t\t\t\tx = (int)(1LL * x * n_1 % mod);",
			"\t\t}",
			"\t}",
			"\t",
			"\tstatic vector<int> multiply(vector<int> const& a, vector<int> const& b) {",
			"\t\tvector<int> fa(a), fb(b);",
			"\t\tint n = 1;",
			"\t\twhile (n < a.size() or n < b.size()) ",
			"\t\t\tn <<= 1;",
			"\t\tfa.resize(n);",
			"\t\tfb.resize(n);",
			"",
			"\t\tfwht(fa, false);",
			"\t\tfwht(fb, false);",
			"\t\tfor (int i = 0; i < n; i++)",
			"\t\t\tfa[i] = (1LL * fa[i] * fb[i] % mod);",
			"\t\tfwht(fa, true);",
			"",
			"\t\treturn fa;",
			"\t}",
			"};"
		],
		"description": "My Fast Walsh Hadamard Transform code."
	},


	"Number Theoretic Transform": {
		"prefix": "number-theoretic-transform",
		"body": [
			"class NTT",
			"{",
			"private:",
			"\tstatic const int mod = 998244353;    // 2^k * c + 1 (998244353 == 2^23 * 7 * 17 + 1)",
			"",
			"\t// Automatic finding of primitive root and nth root of unity currently works only for prime modules of the form 2^k * c + 1",
			"\t",
			"\tstatic const int primitive_root; // g",
			"\tstatic const int root;           // g^c modulo mod",
			"\tstatic const int root_1;         // root^-1 modulo mod",
			"\tstatic const int root_pw;        // 2^k",
			"",
			"\tstatic constexpr long long p (long long x, long long y)",
			"\t{",
			"\t\tlong long ans = 1;",
			"\t\twhile(y)",
			"\t\t{",
			"\t\t\tif(y & 1)",
			"\t\t\t\t(ans *= x) %= mod;",
			"\t\t\t(x *= x) %= mod;",
			"\t\t\ty /= 2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tstatic constexpr long long inv (long long x)",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"",
			"\tstatic constexpr int get_primitive_root()",
			"\t{",
			"\t\tconst int phi = mod - 1;",
			"\t\tint x = phi;",
			"\t\tint powers_to_be_checked[32] = {};",
			"\t\tint powers_to_be_checked_size = 0;",
			"\t\tfor(int i = 2; i * i <= x; i++)",
			"\t\t{",
			"\t\t\tpowers_to_be_checked[powers_to_be_checked_size] = phi / i;",
			"\t\t\tpowers_to_be_checked_size++;",
			"\t\t\twhile(x % i == 0)",
			"\t\t\t\tx /= i;",
			"\t\t}",
			"\t\tint num = 1;",
			"\t\tbool ok = false;",
			"\t\tdo",
			"\t\t{",
			"\t\t\tnum++;",
			"\t\t\tok = true;",
			"\t\t\tfor(int i = 0; i < powers_to_be_checked_size; i++)",
			"\t\t\t\tif(p(num, powers_to_be_checked[i]) == 1)",
			"\t\t\t\t{",
			"\t\t\t\t\tok = false;",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"\t\t} while(!ok);",
			"\t\treturn num;",
			"\t}",
			"",
			"\tstatic constexpr int get_root()",
			"\t{",
			"\t\tint c = mod - 1;",
			"\t\twhile(!(c & 1))",
			"\t\t\tc /= 2;",
			"\t\t// Cannot use primitive_root here directly, Codechef does not allow it.",
			"\t\t// Works on my local machine though.",
			"\t\treturn p(get_primitive_root(), c);",
			"\t}",
			"",
			"\tstatic constexpr int get_root_pw()",
			"\t{",
			"\t\tint two_k = 1, n = mod - 1;",
			"\t\twhile(!(n & 1))",
			"\t\t\ttwo_k *= 2, n /= 2;",
			"\t\treturn two_k;",
			"\t}",
			"",
			"\tstatic void ntt (vector<int> & a, bool invert)",
			"\t{",
			"\t\tint n = a.size();",
			"",
			"\t\tfor (int i = 1, j = 0; i < n; i++) {",
			"\t\t\tint bit = n >> 1;",
			"\t\t\tfor (; j & bit; bit >>= 1)",
			"\t\t\t\tj ^= bit;",
			"\t\t\tj ^= bit;",
			"",
			"\t\t\tif (i < j)",
			"\t\t\t\tswap(a[i], a[j]);",
			"\t\t}",
			"",
			"\t\tfor (int len = 2; len <= n; len <<= 1) {",
			"\t\t\tint wlen = invert ? root_1 : root;",
			"\t\t\tfor (int i = len; i < root_pw; i <<= 1)",
			"\t\t\t\twlen = (int)(1LL * wlen * wlen % mod);",
			"",
			"\t\t\tfor (int i = 0; i < n; i += len) {",
			"\t\t\t\tint w = 1;",
			"\t\t\t\tfor (int j = 0; j < len / 2; j++) {",
			"\t\t\t\t\tint u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);",
			"\t\t\t\t\ta[i+j] = u + v < mod ? u + v : u + v - mod;",
			"\t\t\t\t\ta[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;",
			"\t\t\t\t\tw = (int)(1LL * w * wlen % mod);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif (invert) {",
			"\t\t\tint n_1 = inv(n);",
			"\t\t\tfor (int & x : a)",
			"\t\t\t\tx = (int)(1LL * x * n_1 % mod);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tstatic vector<int> multiply(vector<int> fa, vector<int> fb) {",
			"\t\tint n = 1;",
			"\t\twhile (n < fa.size() + fb.size()) ",
			"\t\t\tn <<= 1;",
			"\t\tfa.resize(n);",
			"\t\tfb.resize(n);",
			"",
			"\t\tntt(fa, false);",
			"\t\tntt(fb, false);",
			"\t\tfor (int i = 0; i < n; i++)",
			"\t\t\tfa[i] = (1LL * fa[i] * fb[i] % mod);",
			"\t\tntt(fa, true);",
			"\t\treturn fa;",
			"\t}",
			"};",
			"const int NTT::primitive_root = NTT::get_primitive_root();",
			"const int NTT::root = NTT::get_root();",
			"const int NTT::root_1 = NTT::inv(root);",
			"const int NTT::root_pw = NTT::get_root_pw();"
		],
		"description": "My Number Theoretic Transform code"
	},


	"Fast Modular Exponentiation": {
		"prefix": "modexp",
		"body": [
			"namespace modexp",
			"{",
			"\tconst int default_mod = 1000000007;",
			"",
			"\tconstexpr long long p (long long x, long long y, int mod = default_mod)",
			"\t{",
			"\t\tlong long ans = 1;",
			"\t\twhile(y)",
			"\t\t{",
			"\t\t\tif(y & 1)",
			"\t\t\t\t(ans *= x) %= mod;",
			"\t\t\t(x *= x) %= mod;",
			"\t\t\ty /= 2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tconstexpr long long inv (const long long x, int mod = default_mod)",
			"\t{",
			"\t\treturn p (x, mod - 2, mod);",
			"\t}",
			"}",
			"using modexp::p;",
			"using modexp::inv;"
		],
		"description": "My fast modular exponentiation code"
	},


	"Gauss Jordan Elimination": {
		"prefix": "gauss-jordan-elimination",
		"body": [
			"class GaussJordanElimination",
			"{",
			"private:",
			"\tstatic constexpr double EPS = 1e-9;",
			"\tvector<double> ans;",
			"\tenum class NumSolutions {unique_solution, no_solution, infinitely_many_solutions} num_solutions = NumSolutions::unique_solution;",
			"",
			"public:",
			"\tGaussJordanElimination(vector<vector<double>> coeffs, vector<double> & vals) : ans(vals)",
			"\t{",
			"\t\tfor(int row = 0; row < coeffs.size(); row++)",
			"\t\t{",
			"\t\t\t// The lambda function is a heuristic to greatly decrease the chances of overflow in later stages of the algorithm",
			"\t\t\tconst int pivot = max_element(",
			"\t\t\t\tcoeffs.begin() + row, coeffs.end(),",
			"\t\t\t\t[row](vector<double> &row1, vector<double> &row2)",
			"\t\t\t\t{return abs(row1[row]) < abs(row2[row]);}",
			"\t\t\t) - coeffs.begin();",
			"",
			"\t\t\tfor(int col = row; col < coeffs[0].size(); col++)",
			"\t\t\t\tswap(coeffs[row][col], coeffs[pivot][col]);",
			"\t\t\tswap(ans[row], ans[pivot]);",
			"",
			"\t\t\tif(abs(coeffs[row][row]) < EPS)",
			"\t\t\t{",
			"\t\t\t\tnum_solutions = NumSolutions::infinitely_many_solutions;",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"",
			"\t\t\tconst double d = coeffs[row][row];",
			"\t\t\tfor(int col = row; col < coeffs[0].size(); col++)",
			"\t\t\t\tcoeffs[row][col] /= d;",
			"\t\t\tans[row] /= d;",
			"",
			"\t\t\tfor(int r = 0; r < coeffs.size(); r++)",
			"\t\t\t{",
			"\t\t\t\tif(r == row)",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\tconst double factor = coeffs[r][row];",
			"\t\t\t\tfor(int c = row; c < coeffs[0].size(); c++)",
			"\t\t\t\t\tcoeffs[r][c] -= coeffs[row][c] * factor;",
			"                ans[r] -= ans[row] * factor;",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif(num_solutions != NumSolutions::unique_solution)",
			"\t\t{",
			"\t\t\tfor(int row = 0; row < coeffs.size(); row++)",
			"\t\t\t\tif(abs(coeffs[row][row]) < EPS and abs(ans[row]) > EPS)",
			"\t\t\t\t{",
			"\t\t\t\t\tnum_solutions = NumSolutions::no_solution;",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tbool has_unique_solution()",
			"\t{",
			"\t\treturn num_solutions == NumSolutions::unique_solution;",
			"\t}",
			"",
			"\tbool has_no_solution()",
			"\t{",
			"\t\treturn num_solutions == NumSolutions::no_solution;",
			"\t}",
			"",
			"\tbool has_infinite_solutions()",
			"\t{",
			"\t\treturn num_solutions == NumSolutions::infinitely_many_solutions;",
			"\t}",
			"",
			"\tconst vector<double> & get_ans()",
			"\t{",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "My code to perform Gauss Jordan Elimination"
	},

	
	"Fenwick Tree": {
		"prefix": "fenwick-tree",
		"body": [
			"template <class T = long long>",
			"class FenwickTree",
			"{",
			"private:",
			"\tvector<T> tree;",
			"\tconst T identity = 0;",
			"\tT merge (const T x, const T y)",
			"\t{",
			"\t\treturn x + y;",
			"\t}",
			"\tT merge_inverse (const T x, const T y)",
			"\t{",
			"\t\treturn x - y;",
			"\t}",
			"\t// index is 0-based",
			"\tT query_0_to_index (int index)",
			"\t{",
			"\t\tT ans = identity;",
			"\t\tindex++;",
			"\t\tfor(; index > 0; index -= index & -index)",
			"\t\t\tans = merge(ans, tree[index]);",
			"\t\treturn ans;",
			"\t}",
			"",
			"public:",
			"\tFenwickTree (const int size)",
			"\t{",
			"\t\ttree.resize(size + 1, identity);",
			"\t}",
			"\t// index is 0-based",
			"\tvoid update (int index, const T delta)",
			"\t{",
			"\t\tindex++;",
			"\t\tfor(; index < tree.size() ; index += index & -index)",
			"\t\t\ttree[index] = merge(tree[index], delta);",
			"\t}",
			"\t// index is 0-based",
			"\tT query (const int l, const int r)",
			"\t{",
			"\t\treturn merge_inverse(query_0_to_index(r), query_0_to_index(l-1));",
			"\t}",
			"};"
		],
		"description": "My Fenwick Tree class"
	},

	
	"Topological Sort": {
		"prefix": "topological-sort",
		"body": [
			"class TopologicalSort",
			"{",
			"private:",
			"\tstatic void dfs(int source, const vector<vector<int>>& adj, vector<int>& vis, stack<int>& rev_stack)",
			"\t{",
			"\t\tvis[source] = 1;",
			"\t\tfor(int next : adj[source])",
			"\t\t\tif(!vis[next])",
			"\t\t\t\tdfs(next, adj, vis, rev_stack);",
			"\t\trev_stack.push(source);",
			"\t}",
			"\t",
			"public:",
			"\t// Note that this ordering is not compatible for finding strongly connected components.",
			"\t// This method expects a Directed Acyclic Graph.",
			"\tstatic vector<int> get(const vector<vector<int>>& adj)",
			"\t{",
			"\t\tvector<int> vis(adj.size());",
			"\t\tstack<int> rev_stack;",
			"\t\tfor(int i = 0; i < adj.size(); i++)",
			"\t\t\tif(!vis[i])",
			"\t\t\t\tdfs(i, adj, vis, rev_stack);",
			"\t\tvector<int> ordering;",
			"\t\twhile(!rev_stack.empty())",
			"\t\t{",
			"\t\t\tordering.push_back(rev_stack.top());",
			"\t\t\trev_stack.pop();",
			"\t\t}",
			"\t\treturn ordering;",
			"\t}",
			"};"
		],
		"description": "Code for Topological Sort"
	},


	"Convex Hull": {
		"prefix": "convex-hull",
		"body": [
			"class Line",
			"{",
			"public:",
			"\t// Represents a line with the equation y = mx + c",
			"\tconst int m, c;",
			"\t// rightx is the x coordinate of the intersection point of the line",
			"\t// with the line just right to it in the Convex Hull.",
			"\tmutable float rightx;",
			"\tLine(const int _m, const int _c) : m(_m), c(_c) {}",
			"\tbool operator < (const Line& l) const { return m < l.m; }",
			"\tbool operator < (const float x) const { return rightx < x; }",
			"\t// intersectx handles the case of intersection of two parallel lines",
			"\t// for ConvexHull::isect as well.",
			"\tfloat intersectx(const Line& l) const { return float(c - l.c) / (l.m - m); }",
			"};",
			"",
			"class ConvexHull : private multiset<Line, less<>>",
			"{",
			"private:",
			"\tstatic constexpr float inf = numeric_limits<float>::infinity();",
			"\tbool isect(const iterator x, const iterator y) const",
			"\t{",
			"\t\tif (y == end()) { x->rightx = inf; return false; }",
			"\t\tx->rightx = x->intersectx(*y);",
			"\t\treturn x->rightx >= y->rightx;",
			"\t}",
			"public:",
			"\tvoid add_line(const int m, const int c)",
			"\t{",
			"\t\titerator y = insert(Line(m, c)), x = y++;",
			"\t\twhile (isect(x, y)) y = erase(y);",
			"\t\ty = x;",
			"\t\tif (x != begin() and isect(--x, y)) isect(x, y = erase(y));",
			"\t\twhile ((y = x) != begin() and (--x)->rightx >= y->rightx)",
			"\t\t\tisect(x, erase(y));",
			"\t}",
			"\tfloat query(const float x) const",
			"\t{",
			"\t\tassert(!empty());",
			"\t\tauto l = *lower_bound(x);",
			"\t\treturn l.m * x + l.c;",
			"\t}",
			"};"
		],
		"description": "Fully dynamic convex hull code"
	},


	"Undirected Graph class": {
		"prefix": "undirected-graph",
		"body": [
			"class UndirectedGraph",
			"{",
			"private:",
			"\tconst vector<vector<int>> M;",
			"",
			"\tint diameter_helper(const int x, const int par, int &ans) const",
			"\t{",
			"\t\tpriority_queue<int, vector<int>, greater<int>> pq;",
			"\t\tpq.push(0);",
			"\t\tpq.push(0);",
			"\t\tfor(const int y : M[x])",
			"\t\t{",
			"\t\t\tif(y == par)",
			"\t\t\t\tcontinue;",
			"\t\t\tpq.push(diameter_helper(y, x, ans));",
			"\t\t\tpq.pop();",
			"\t\t}",
			"\t\tint cur_diameter = pq.top();",
			"\t\tpq.pop();",
			"\t\tcur_diameter += pq.top();",
			"\t\tans = max(ans, cur_diameter);",
			"\t\treturn 1 + pq.top();",
			"\t}",
			"",
			"public:",
			"\tUndirectedGraph(const vector<vector<int>> &_M) : M(_M) {}",
			"",
			"\tint diameter() const",
			"\t{",
			"\t\tint ans = 0;",
			"\t\tdiameter_helper(0, -1, ans);",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "Contains graph operations"
	},


	"Get Primes": {
		"prefix": "get-primes-upto",
		"body": [
			"vector<int> get_primes_upto(int n)",
			"{",
			"\tvector<int> composite(n);",
			"\tcomposite[0] = 1;",
			"\tfor(int i = 2; i <= n; i++)",
			"\t{",
			"\t\tif(composite[i-1])",
			"\t\t\tcontinue;",
			"\t\tfor(int j = 2 * i; j <= n; j += i)",
			"\t\t\tcomposite[j-1] = 1;",
			"\t}",
			"\tvector<int> primes;",
			"\tfor(int i = 1; i <= n; i++)",
			"\t\tif(!composite[i-1])",
			"\t\t\tprimes.push_back(i);",
			"\treturn primes;",
			"}"
		],
		"description": "Get primes upto an integer n"
	},


	"Modular Polynomial": {
		"prefix": "polynomial-modular",
		"body": [
			"class Poly_modular",
			"{",
			"private:",
			"\tstatic const int default_mod = 1000000007;",
			"\tconst int mod;",
			"",
			"\tconstexpr long long p (long long x, long long y) const",
			"\t{",
			"\t\tlong long ans = 1;",
			"\t\twhile(y)",
			"\t\t{",
			"\t\t\tif(y & 1)",
			"\t\t\t{",
			"\t\t\t\t(ans *= x) %= mod;",
			"\t\t\t}",
			"\t\t\t(x *= x) %= mod;",
			"\t\t\ty /= 2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tconstexpr long long inv (const long long x) const",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"",
			"public:",
			"\tvector<long long> coeffs;",
			"",
			"\tPoly_modular(const int _mod = default_mod) : mod(_mod) {}",
			"\tPoly_modular(const vector<long long> &_coeffs, const int _mod = default_mod) : coeffs(_coeffs), mod(_mod) {}",
			"\tPoly_modular(const initializer_list<long long> &_coeffs, const int _mod = default_mod) : coeffs(_coeffs), mod(_mod) {}",
			"",
			"\tPoly_modular& operator *= (const Poly_modular& poly)",
			"\t{",
			"\t\tif(poly.coeffs.empty())",
			"\t\t{",
			"\t\t\tcoeffs.clear();",
			"\t\t\treturn *this;",
			"\t\t}",
			"\t\tint old_size = coeffs.size();",
			"\t\tcoeffs.resize(coeffs.size() + poly.coeffs.size() - 1);",
			"\t\tfor(int i = old_size - 1; i > -1; i--)",
			"\t\t{",
			"\t\t\tfor(int j = poly.coeffs.size() - 1; j > 0; j--)",
			"\t\t\t{",
			"\t\t\t\t(coeffs[i + j] += coeffs[i] * poly.coeffs[j] % h) %= h;",
			"\t\t\t}",
			"\t\t\t(coeffs[i] *= poly.coeffs[0]) %= h;",
			"\t\t}",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tPoly_modular operator * (const Poly_modular &poly) const",
			"\t{",
			"\t\treturn Poly_modular(*this) *= poly;",
			"\t}",
			"",
			"\tPoly_modular& operator *= (const long long c)",
			"\t{",
			"\t\treturn *this *= Poly_modular({c});",
			"\t}",
			"\t",
			"\tPoly_modular operator * (const long long c) const",
			"\t{",
			"\t\treturn Poly_modular(*this) *= c;",
			"\t}",
			"",
			"\tPoly_modular& operator /= (const long long c)",
			"\t{",
			"\t\treturn *this *= Poly_modular({inv(c)});",
			"\t}",
			"\t",
			"\tPoly_modular operator / (const long long c) const",
			"\t{",
			"\t\treturn Poly_modular(*this) /= c;",
			"\t}",
			"\t",
			"\tPoly_modular multiply (const Poly_modular &poly) const",
			"\t{",
			"\t\treturn *this * poly;",
			"\t}",
			"\t",
			"\tPoly_modular multiply (const long long c) const",
			"\t{",
			"\t\treturn *this * c;",
			"\t}",
			"\t",
			"\tPoly_modular divide (const long long c) const",
			"\t{",
			"\t\treturn *this / c;",
			"\t}",
			"",
			"\tlong long evaluate(long long x) const",
			"\t{",
			"\t\tlong long xp = 1, ans = 0;",
			"\t\tfor(long long c : coeffs)",
			"\t\t{",
			"\t\t\t(ans += c * xp % mod) %= mod;",
			"\t\t\t(xp *= x) %= mod;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tPoly_modular differentiate() const",
			"\t{",
			"\t\tvector<long long> d(coeffs);",
			"\t\tif(d.empty())",
			"\t\t{",
			"\t\t\treturn Poly_modular(mod);",
			"\t\t}",
			"\t\td.erase(d.begin());",
			"\t\tfor(int i = 0; i < d.size(); i++)",
			"\t\t{",
			"\t\t\t(d[i] *= i + 1) %= mod;",
			"\t\t}",
			"\t\treturn Poly_modular(d);",
			"\t}",
			"",
			"\tPoly_modular integrate() const",
			"\t{",
			"\t\tvector<long long> ig(coeffs);",
			"\t\tig.insert(ig.begin(), 0);",
			"\t\tfor(int i = 1; i < ig.size(); i++)",
			"\t\t{",
			"\t\t\t(ig[i] *= inv(i)) %= mod;",
			"\t\t}",
			"\t\treturn Poly_modular(ig);",
			"\t}",
			"};"
		],
		"description": "Modular polynomial class"
	},


	"Longest Increasing Subsequence": {
		"prefix": "longest-increasing-subsequence",
		"body": [
			"template <class Iterator, class Compare>",
			"int lis_length (const Iterator begin, const Iterator end, const Compare cmp)",
			"{",
			"\tusing T = typename iterator_traits<Iterator>::value_type;",
			"\tconst int len = end - begin;",
			"\t// dp[i] = (smallest element with which a list of subsequence of length i + 1 ends, is any such list attainable)",
			"\t// boolean value is required for using generic compare function",
			"\tvector<pair<T, bool>> dp(len, {T(), false});",
			"\tconst auto dp_cmp = [&cmp] (const pair<T, bool> &x, const pair<T, bool> &y) -> bool {",
			"\t\treturn (x.second == true and y.second == true ? cmp(x.first, y.first) : x.second);",
			"\t};",
			"\tfor (Iterator it = begin; it != end; it++)",
			"\t{",
			"\t\t*lower_bound(dp.begin(), dp.end(), make_pair(*it, true), dp_cmp) = {*it, true};",
			"\t}",
			"\treturn lower_bound(dp.begin(), dp.end(), make_pair(T(), false), dp_cmp) - dp.begin();",
			"}",
			"",
			"template <class Iterator>",
			"int lis_length (const Iterator begin, const Iterator end)",
			"{",
			"\tusing T = typename iterator_traits<Iterator>::value_type;",
			"\treturn lis_length(begin, end, less<T>());",
			"}"
		],
		"description": "Code for finding Longest Increasing Subsequence"
	},


	"Binomial Coefficients": {
		"prefix": "binomal-coefficients",
		"body": [
			"class ncr",
			"{",
			"private:",
			"\tstatic const int mod = 1000000007;",
			"\tstatic const int max_n = 300000;",
			"\tstatic bool initialized;",
			"",
			"\tstatic array<long long, max_n + 1> fact, inv_fact;",
			"",
			"\tstatic constexpr long long p (long long x, long long y)",
			"\t{",
			"\t\tlong long ans = 1;",
			"\t\twhile(y)",
			"\t\t{",
			"\t\t\tif(y & 1)",
			"\t\t\t\t(ans *= x) %= mod;",
			"\t\t\t(x *= x) %= mod;",
			"\t\t\ty /= 2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tstatic constexpr long long inv (long long x)",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"",
			"\tstatic void initialize()",
			"\t{",
			"\t\tfact[0] = inv_fact[0] = 1;",
			"\t\tfor(int i = 1; i <= max_n; i++)",
			"\t\t{",
			"\t\t\tfact[i] = fact[i-1] * i % mod;",
			"\t\t\tinv_fact[i] = inv(fact[i]);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tstatic get (const int n, const int r)",
			"\t{",
			"\t\tif(!initialized)",
			"\t\t{",
			"\t\t\tinitialized = true;",
			"\t\t\tinitialize();",
			"\t\t}",
			"\t\treturn fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod;",
			"\t}",
			"};",
			"array<long long, ncr::max_n + 1> ncr::fact = {};",
			"array<long long, ncr::max_n + 1> ncr::inv_fact = {};",
			"bool ncr::initialized = false;"
		],
		"description": "Code to calculate binomial coefficients"
	},


	"Graph": {
		"prefix": "graph",
		"body": [
			"class Graph",
			"{",
			"private:",
			"\tconst vector<vector<pair<int, long long>>> adj;",
			"",
			"\tconst vector<vector<pair<int, long long>>> get_weighted_adj(const vector<vector<int>> &unweighted_adj) const",
			"\t{",
			"\t\tvector<vector<pair<int, long long>>> weighted_adj(unweighted_adj.size());",
			"\t\tfor(int i = 0; i < unweighted_adj.size(); i++)",
			"\t\t{",
			"\t\t\tfor(int j = 0; j < unweighted_adj[i].size(); j++)",
			"\t\t\t{",
			"\t\t\t\tweighted_adj[i].push_back({unweighted_adj[i][j], 1LL});",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn weighted_adj;",
			"\t}",
			"",
			"public:",
			"\tGraph(const vector<vector<pair<int, long long>>> &_adj) : adj(_adj) {}",
			"\tGraph(const vector<vector<int>> &_adj) : adj(get_weighted_adj(_adj)) {}",
			"",
			"\tbool is_bipartite() const",
			"\t{",
			"\t\tvector<bool> vis(adj.size()), col(adj.size());",
			"\t\tfor(int i = 0; i < adj.size(); i++)",
			"\t\t{",
			"\t\t\tif(vis[i])",
			"\t\t\t\tcontinue;",
			"\t\t\tstack<int> st;",
			"\t\t\tvis[i] = true;",
			"\t\t\tst.push(i);",
			"\t\t\twhile(!st.empty())",
			"\t\t\t{",
			"\t\t\t\tconst int x = st.top();",
			"\t\t\t\tst.pop();",
			"\t\t\t\tfor(const pair<int, long long> &p : adj[x])",
			"\t\t\t\t{",
			"\t\t\t\t\tif(vis[p.first])",
			"\t\t\t\t\t{",
			"\t\t\t\t\t\tif(col[p.first] == col[x])",
			"\t\t\t\t\t\t\treturn false;",
			"\t\t\t\t\t\tcontinue;",
			"\t\t\t\t\t}",
			"\t\t\t\t\tcol[p.first] = !col[x];",
			"\t\t\t\t\tvis[p.first] = true;",
			"\t\t\t\t\tst.push(p.first);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn true;",
			"\t}",
			"",
			"\tlong long distance(const int source, const int destination) const",
			"\t{",
			"\t\tvector<bool> vis(adj.size());",
			"\t\tpriority_queue<pair<int, long long>, vector<pair<int, long long>>, greater<pair<int, long long>>> pq;",
			"\t\tpq.push({0, source});",
			"\t\twhile(!pq.empty())",
			"\t\t{",
			"\t\t\tconst long long w = pq.top().first;",
			"\t\t\tconst int x = pq.top().second;",
			"\t\t\tpq.pop();",
			"\t\t\tif(x == destination)",
			"\t\t\t\treturn w;",
			"\t\t\tif(vis[x])",
			"\t\t\t\tcontinue;",
			"\t\t\tvis[x] = true;",
			"\t\t\tfor(const pair<int, long long> &p : adj[x])",
			"\t\t\t\tpq.push({w + p.S, p.F});",
			"\t\t}",
			"\t\treturn numeric_limits<long long>::max();",
			"\t}",
			"};"
		],
		"description": "Graph class"
	},
	"Heavy Light Decomposition": {
		"prefix": "heavy-light-decomposition",
		"body": [
			"class HLD",
			"{",
			"private:",
			"\tvector<int> par, depth, seg_ind, head, head_par, parent_edge_weight;",
			"\tvector<SegTree<int>> seg;",
			"",
			"\tint dfs(const int x, const int d, const vector<vector<pair<int, int>>> &adj, vector<int> &heavy_child)",
			"\t{",
			"\t\tint size = 1;",
			"\t\tint heavy_size = 0;",
			"\t\tdepth[x] = d;",
			"\t\tfor(const pair<int, int> p : adj[x])",
			"\t\t{",
			"\t\t\tconst int y = p.first;",
			"\t\t\tconst int w = p.second;",
			"\t\t\tif(y == par[x])",
			"\t\t\t{",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tpar[y] = x;",
			"\t\t\tparent_edge_weight[y] = w;",
			"\t\t\tconst int y_size = dfs(y, d + 1, adj, heavy_child);",
			"\t\t\tif(y_size > heavy_size)",
			"\t\t\t{",
			"\t\t\t\theavy_size = y_size;",
			"\t\t\t\theavy_child[x] = y;",
			"\t\t\t}",
			"\t\t\tsize += y_size;",
			"\t\t}",
			"\t\treturn size;",
			"\t}",
			"",
			"\tvoid decompose(const int x, const int seg_index, const vector<vector<pair<int, int>>> &adj, const vector<int> &heavy_child, vector<vector<int>> &seg_vecs)",
			"\t{",
			"\t\tif(seg_index == seg_vecs.size())",
			"\t\t{",
			"\t\t\tseg_vecs.resize(seg_vecs.size() + 1);",
			"\t\t\thead.push_back(x);",
			"\t\t\thead_par.push_back(par[x]);",
			"\t\t}",
			"\t\tseg_ind[x] = seg_index;",
			"\t\tseg_vecs[seg_index].push_back(parent_edge_weight[x]);",
			"\t\tfor(const pair<int, int> p : adj[x])",
			"\t\t{",
			"\t\t\tconst int y = p.first;",
			"\t\t\tif(y == par[x])",
			"\t\t\t{",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tif(y == heavy_child[x])",
			"\t\t\t{",
			"\t\t\t\tdecompose(y, seg_index, adj, heavy_child, seg_vecs);",
			"\t\t\t}",
			"\t\t\telse",
			"\t\t\t{",
			"\t\t\t\tdecompose(y, seg_vecs.size(), adj, heavy_child, seg_vecs);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid create_segment_trees(vector<vector<int>> &seg_vecs)",
			"\t{",
			"\t\tfor(int i = 0; i < seg_vecs.size(); i++)",
			"\t\t{",
			"\t\t\tseg.emplace_back(seg_vecs[i]);",
			"\t\t}",
			"\t}",
			"",
			"\tint get_pos(const int x) const",
			"\t{",
			"\t\treturn depth[x] - depth[head[seg_ind[x]]];",
			"\t}",
			"",
			"public:",
			"\tHLD(const vector<vector<pair<int, int>>> &adj) : par(adj.size()), depth(adj.size()), seg_ind(adj.size()), parent_edge_weight(adj.size())",
			"\t{",
			"\t\tvector<int> heavy_child(adj.size(), -1);",
			"\t\tdfs(0, 0, adj, heavy_child);",
			"\t\tvector<vector<int>> seg_vecs;",
			"\t\tdecompose(0, 0, adj, heavy_child, seg_vecs);",
			"\t\tcreate_segment_trees(seg_vecs);",
			"\t}",
			"",
			"\tvoid update_node(const int x, const int val)",
			"\t{",
			"\t\tseg[seg_ind[x]].update(get_pos(x), val);",
			"\t}",
			"",
			"\tvoid update_edge(int x, int y, const int w)",
			"\t{",
			"\t\tif(par[y] == x)",
			"\t\t{",
			"\t\t\tswap(x, y);",
			"\t\t}",
			"\t\t// Now, par[x] == y",
			"\t\tseg[seg_ind[x]].update(get_pos(x), w);",
			"\t}",
			"",
			"\tint query(int x, int y, const bool edge_like = false)",
			"\t{",
			"\t\tint ans = INT_MIN;",
			"\t\twhile(seg_ind[x] != seg_ind[y])",
			"\t\t{",
			"\t\t\tif(depth[head[seg_ind[x]]] < depth[head[seg_ind[y]]])",
			"\t\t\t{",
			"\t\t\t\tswap(x, y);",
			"\t\t\t}",
			"\t\t\tans = max(ans, seg[seg_ind[x]].query(0, get_pos(x)));",
			"\t\t\tx = head_par[seg_ind[x]];",
			"\t\t}",
			"\t\tint l = get_pos(x), r = get_pos(y);",
			"\t\tif(l > r)",
			"\t\t{",
			"\t\t\tswap(l, r);",
			"\t\t}",
			"\t\tans = max(ans, seg[seg_ind[x]].query(l + edge_like, r));",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "Heavy Light Decomposition code"
	},

	
	"Segment Tree with Lazy Propagation": {
		"prefix": "segment-tree-lazy",
		"body": [
			"template <class seg_T = long long, class upd_T = long long>",
			"class SegTree",
			"{",
			"private:",
			"\tstatic const upd_T update_identity;",
			"\tseg_T merge_elem(const seg_T&, const seg_T&) const;",
			"\tupd_T merge_upd(const upd_T& upd1, const upd_T& upd2) const;",
			"\tseg_T update_elem(const seg_T& val, const upd_T& upd, const int num_elems) const;",
			"\tconst int underlying_array_size;",
			"\tvector<seg_T> seg_tree;",
			"\tvector<upd_T> lazy;",
			"\tvoid build(const int node, const int start, const int end, const vector<seg_T>& v)",
			"\t{",
			"\t\tif(start == end)",
			"\t\t{",
			"\t\t\tseg_tree[node] = v[start];",
			"\t\t}",
			"\t\telse",
			"\t\t{",
			"\t\t\tconst int mid = (start + end) / 2;",
			"\t\t\tbuild(2 * node + 1, start, mid, v);",
			"\t\t\tbuild(2 * node + 2, mid + 1, end, v);",
			"\t\t\tseg_tree[node] = merge_elem(seg_tree[2 * node + 1], seg_tree[2 * node + 2]);",
			"\t\t}",
			"\t}",
			"\tvoid update_range(const int node, const int start, const int end, const int l, const int r, const upd_T& val)",
			"\t{",
			"\t\tif(l <= start and end <= r)",
			"\t\t\tlazy[node] = merge_upd(lazy[node], val);",
			"\t\tif(lazy[node] != update_identity and start != end)",
			"\t\t{",
			"\t\t\tlazy[2 * node + 1] = merge_upd(lazy[2 * node + 1], lazy[node]);",
			"\t\t\tlazy[2 * node + 2] = merge_upd(lazy[2 * node + 2], lazy[node]);",
			"\t\t}",
			"\t\tif(end < l or r < start or (l <= start and end <= r))",
			"\t\t{",
			"\t\t\tseg_tree[node] = update_elem(seg_tree[node], lazy[node], end - start + 1);",
			"\t\t\tlazy[node] = update_identity;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tlazy[node] = update_identity;",
			"\t\tconst int mid = (start + end) / 2;",
			"\t\tupdate_range(2 * node + 1, start, mid, l, r, val);",
			"\t\tupdate_range(2 * node + 2, mid + 1, end, l, r, val);",
			"\t\tseg_tree[node] = merge_elem(seg_tree[2 * node + 1], seg_tree[2 * node + 2]);",
			"\t}",
			"\tseg_T query(const int node, const int start, const int end, const int l, const int r)",
			"\t{",
			"\t\tif(lazy[node] != update_identity)",
			"\t\t{",
			"\t\t\tif(start != end)",
			"\t\t\t{",
			"\t\t\t\tlazy[2 * node + 1] = merge_upd(lazy[2 * node + 1], lazy[node]);",
			"\t\t\t\tlazy[2 * node + 2] = merge_upd(lazy[2 * node + 2], lazy[node]);",
			"\t\t\t}",
			"\t\t\tseg_tree[node] = update_elem(seg_tree[node], lazy[node], end - start + 1);",
			"\t\t\tlazy[node] = update_identity;",
			"\t\t}",
			"\t\tif(l <= start and end <= r)",
			"\t\t\treturn seg_tree[node];",
			"\t\tconst int mid = (start + end) / 2;",
			"\t\tif(r <= mid)",
			"\t\t\treturn query(2 * node + 1, start, mid, l, r);",
			"\t\telse if(l > mid)",
			"\t\t\treturn query(2 * node + 2, mid + 1, end, l, r);",
			"\t\treturn merge_elem(",
			"\t\t\tquery(2 * node + 1, start, mid, l, r),",
			"\t\t\tquery(2 * node + 2, mid + 1, end, l, r)",
			"\t\t);",
			"\t}",
			"",
			"public:",
			"\tSegTree(const int n, const seg_T val)",
			"\t\t: underlying_array_size(n),",
			"\t\tseg_tree(4 * underlying_array_size, val),",
			"\t\tlazy(4 * underlying_array_size, update_identity)",
			"\t{",
			"\t\tconst vector<seg_T> v(underlying_array_size, val);",
			"\t\tbuild(0, 0, underlying_array_size - 1, v);",
			"\t}",
			"\tSegTree(const vector<seg_T>& v)",
			"\t\t: underlying_array_size(v.size()),",
			"\t\tseg_tree(4 * underlying_array_size),",
			"\t\tlazy(4 * underlying_array_size, update_identity)",
			"\t{",
			"\t\tbuild(0, 0, underlying_array_size - 1, v);",
			"\t}",
			"\tint size() const",
			"\t{",
			"\t\treturn underlying_array_size;",
			"\t}",
			"\tvoid update_range(const int l, const int r, const upd_T& val)",
			"\t{",
			"\t\tupdate_range(0, 0, underlying_array_size - 1, l, r, val);",
			"\t}",
			"\tseg_T query(const int l, const int r)",
			"\t{",
			"\t\treturn query(0, 0, underlying_array_size - 1, l, r);",
			"\t}",
			"};",
			"",
			"// Modify as required",
			"",
			"template <class seg_T, class upd_T>",
			"const upd_T SegTree<seg_T, upd_T>::update_identity = 0;",
			"",
			"template <class seg_T, class upd_T>",
			"seg_T SegTree<seg_T, upd_T>::merge_elem(const seg_T& val1, const seg_T& val2) const",
			"{",
			"\treturn max(val1, val2);",
			"}",
			"",
			"template <class seg_T, class upd_T>",
			"upd_T SegTree<seg_T, upd_T>::merge_upd(const upd_T& upd1, const upd_T& upd2) const",
			"{",
			"\treturn upd1 + upd2;",
			"}",
			"",
			"template <class seg_T, class upd_T>",
			"seg_T SegTree<seg_T, upd_T>::update_elem(const seg_T& val, const upd_T& upd, const int num_elems) const",
			"{",
			"\treturn val + upd;",
			"}"
		],
		"description": "My code for a segment tree with lazy propagation"
	}
}
