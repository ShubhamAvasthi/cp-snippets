{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	
	
	"Segment Tree": {
		"prefix": "segment-tree",
		"body": [
			"template <class T = long long>",
			"class SegTree",
			"{",
			"private:",
			"\tT default_element_value = 0;",
			"\tvector<T> v, seg_tree;",
			"\tT merge(T x, T y)",
			"\t{",
			"\t\treturn max(x, y);",
			"\t}",
			"\tvoid build(int node, int start, int end)",
			"\t{",
			"\t\tif(start == end)",
			"\t\t\tseg_tree[node] = v[start];",
			"\t\telse",
			"\t\t{",
			"\t\t\tbuild(2*node+1, start, (start+end)/2);",
			"\t\t\tbuild(2*node+2, (start+end)/2+1, end);",
			"\t\t\tseg_tree[node] = merge(seg_tree[2*node+1], seg_tree[2*node+2]);",
			"\t\t}",
			"\t}",
			"\tvoid update(int node, int start, int end, int index, T val)",
			"\t{",
			"\t\tif(start == end)",
			"\t\t{",
			"\t\t\tseg_tree[node] = val;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tif(index<=(start+end)/2)",
			"\t\t\tupdate(2*node+1, start, (start+end)/2, index, val);",
			"\t\telse",
			"\t\t\tupdate(2*node+2, (start+end)/2+1, end, index, val);",
			"\t\tseg_tree[node] = merge(seg_tree[2*node+1], seg_tree[2*node+2]);",
			"\t}",
			"\tT query(int node, int start, int end, int l, int r)",
			"\t{",
			"\t\tif(end<l || start>r)",
			"\t\t\treturn default_element_value;",
			"\t\tif(start>=l && end<=r)",
			"\t\t\treturn seg_tree[node];",
			"\t\treturn merge(",
			"\t\t\tquery(2*node+1, start, (start+end)/2, l, r),",
			"\t\t\tquery(2*node+2, (start+end)/2+1, end, l, r));",
			"\t}",
			"",
			"public:",
			"\tSegTree(int n)",
			"\t{",
			"\t\tv.resize(n, default_element_value); //except its size, v won't be used anymore",
			"\t\tseg_tree.resize(4 * n, default_element_value);",
			"\t}",
			"\tSegTree(vector<T> &arr)",
			"\t{",
			"\t\tv = arr;",
			"\t\tseg_tree.resize(4 * v.size(), default_element_value);",
			"\t\tbuild(0, 0, v.size()-1);",
			"\t}",
			"\tvoid update(int index, T val)",
			"\t{",
			"\t\tupdate(0, 0, v.size()-1, index, val);",
			"\t}",
			"\tT query(int l, int r)",
			"\t{",
			"\t\treturn query(0, 0, v.size()-1, l, r);",
			"\t}",
			"};"
		],
		"description": "My segment tree code"
	},


	"Disjoint Set Union": {
		"prefix": "disjoint-set-union",
		"body": [
			"class DSU",
			"{",
			"private:",
			"\tvector<int> par, size;",
			"\tint distinct_sets_count;",
			"",
			"public:",
			"\tDSU(int n)",
			"\t{",
			"\t\tdistinct_sets_count = n;",
			"\t\tpar.resize(n);",
			"\t\tfor(int i = 0; i < n; i++)",
			"\t\t\tpar[i] = i;",
			"\t\tsize.resize(n, 1);",
			"\t}",
			"",
			"\tint root(const int x)",
			"\t{",
			"\t\tif(par[x] == x)",
			"\t\t\treturn x;",
			"\t\treturn par[x] = root(par[x]);",
			"\t}",
			"",
			"\tvoid connect(int a, int b)",
			"\t{",
			"\t\ta = root(a), b = root(b);",
			"\t\tif(a == b) return;",
			"\t\tif(size[a] < size[b])",
			"\t\t\tswap(a, b);",
			"\t\tsize[a] += size[b];",
			"\t\tpar[b] = a;",
			"\t\tdistinct_sets_count--;",
			"\t}",
			"",
			"\tbool same_component(const int x, const int y)",
			"\t{",
			"\t\treturn root(x) == root(y);",
			"\t}",
			"",
			"\tbool is_leader(const int x)",
			"\t{",
			"\t\treturn root(x) == x;",
			"\t}",
			"",
			"\tint size_of_component(const int x)",
			"\t{",
			"\t\treturn size[root(x)];",
			"\t}",
			"",
			"\tint count() const",
			"\t{",
			"\t\treturn distinct_sets_count;",
			"\t}",
			"};"
		],
		"description": "Disjoint Set Union class"
	},


	"Euler's Totient function": {
		"prefix": "totient",
		"body": [
			"long long phi(long long n)",
			"{",
			"\tlong long ans = n;",
			"\tfor(long long i = 2; i * i <= n; i++)",
			"\t\tif(n % i == 0)",
			"\t\t{",
			"\t\t\tans -= ans / i;",
			"\t\t\twhile(n % i == 0)",
			"\t\t\t\tn /= i;",
			"\t\t}",
			"\tif(n > 1)",
			"\t\tans -= ans / n;",
			"\treturn ans;",
			"}"
		],
		"description": "Euler's Totient function"
	},


	"Manacher's Algorithm": {
		"prefix": "manacher",
		"body": [
			"class Manacher",
			"{",
			"\tpublic:",
			"\tvector<int> d1, d2;",
			"",
			"\tManacher (string s)",
			"\t{",
			"\t\td1.resize(s.size());",
			"\t\td2.resize(s.size() - 1);",
			"\t\tfor (int i = 0, l = -1, r = -1; i < s.size(); i++)",
			"\t\t{",
			"\t\t\tint k = (i > r) ? 0 : min(d1[l + r - i], r - i + 1);",
			"\t\t\twhile (i - k > - 1 and i + k < s.size() and s[i - k] == s[i + k])",
			"\t\t\t\tk++;",
			"\t\t\td1[i] = k;",
			"\t\t\tif (i + d1[i] - 1 > r)",
			"\t\t\t{",
			"\t\t\t\tl = i - d1[i] + 1;",
			"\t\t\t\tr = i + d1[i] - 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor (int i = 0, l = -1, r = -1; i < s.size() - 1; i++)",
			"\t\t{",
			"\t\t\tint k = (i > r - 1) ? 0 : min(d2[l + r - i - 1], r - i);",
			"\t\t\twhile (i - k > - 1 and i + 1 + k < s.size() and s[i - k] == s[i + 1 + k])",
			"\t\t\t\tk++;",
			"\t\t\td2[i] = k;",
			"\t\t\tif (i + d2[i] > r)",
			"\t\t\t{",
			"\t\t\t\tl = i - d2[i] + 1;",
			"\t\t\t\tr = i + d2[i];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"};",
			""
		],
		"description": "Manacher's Algorithm"
	},


	"Binary Lifting": {
		"prefix": "binary-lifting",
		"body": [
			"class BinaryLifting",
			"{",
			"private:",
			"\tstatic const int max_power_of_2 = 24;",
			"\tarray<vector<int>, max_power_of_2 + 1> sp;",
			"",
			"\tvoid dfs (int x, int p, int lev, vector<vector<int>> &M)",
			"\t{",
			"\t\tsp[0][x] = p;",
			"\t\tfor(int y : M[x])",
			"\t\t{",
			"\t\t\tif(sp[0][y] != -1) continue;",
			"\t\t\tdfs(y, x, lev + 1, M);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tBinaryLifting (vector<vector<int>> &M)",
			"\t{",
			"\t\tfor(vector<int> &x : sp)",
			"\t\t\tx.resize(M.size(), -1);",
			"\t\tdfs(0, 0, 0, M);",
			"\t\tfor (int i = 1; i <= max_power_of_2; i++)",
			"\t\t\tfor (int j = 0; j < M.size(); j++)",
			"\t\t\t\tsp[i][j] = sp[i-1][sp[i-1][j]];",
			"\t}",
			"",
			"\tint lift (int x, int d)",
			"\t{",
			"\t\tfor (int i = max_power_of_2; i > -1; i--)",
			"\t\t\tif(d >= 1 << i)",
			"\t\t\t{",
			"\t\t\t\td -= 1 << i;",
			"\t\t\t\tx = sp[i][x];",
			"\t\t\t}",
			"\t\treturn x;",
			"\t}",
			"};"
		],
		"description": "My binary lifting code"
	},


	"Time it": {
		"prefix": "time-it",
		"body": [
			"auto start_time = chrono::high_resolution_clock::now();",
			"",
			"auto end_time = chrono::high_resolution_clock::now();",
			"chrono::high_resolution_clock::duration time_duration = end_time - start_time;",
			"",
			"auto h  = chrono::duration_cast<chrono::hours>(time_duration);",
			"time_duration -= h;",
			"auto m  = chrono::duration_cast<chrono::minutes>(time_duration);",
			"time_duration -= m;",
			"auto s  = chrono::duration_cast<chrono::seconds>(time_duration);",
			"time_duration -= s;",
			"auto ms = chrono::duration_cast<chrono::milliseconds>(time_duration);",
			"",
			"cerr<<\"Execution Time: \"",
			"<< h.count()  << \" hours \"",
			"<< m.count()  << \" minutes \"",
			"<< s.count()  << \" seconds \"",
			"<< ms.count() << \" milliseconds\\n\";"
		],
		"description": "Code to print the execution time of a section of code"
	},


	"Fast Walsh Hadamard Transform": {
		"prefix": "fast-walsh-hadamard-transform",
		"body": [
			"class FWHT",
			"{",
			"private:",
			"\tstatic const int mod = 1000000007;",
			"",
			"\tstatic long long p (long long x, long long y)",
			"\t{",
			"\t\tif (y == 0) return 1;",
			"\t\tlong long z = p (x, y / 2);",
			"\t\tz *= z;",
			"\t\tz %= mod;",
			"\t\treturn (y & 1 ? (z * x) % mod : z);",
			"\t}",
			"",
			"\tstatic long long inv (long long x)",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"",
			"public:",
			"\tstatic void fwht (vector<int> & a, bool invert) {",
			"\t\tint n = a.size();",
			"\t\tfor (int len = 1; 2 * len <= n; len <<= 1) {",
			"\t\t\tfor (int i = 0; i < n; i += 2 * len) {",
			"\t\t\t\tfor (int j = 0; j < len; j++) {",
			"\t\t\t\t\tint u = a[i + j];",
			"\t\t\t\t\tint v = a[i + j + len];",
			"\t\t\t\t\ta[i + j] = u + v < mod ? u + v : u + v - mod;",
			"\t\t\t\t\ta[i + j + len] = u - v >= 0 ? u - v : u - v + mod;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (invert) {",
			"\t\t\tint n_1 = inv(n);",
			"\t\t\tfor (int & x : a)",
			"\t\t\t\tx = (int)(1LL * x * n_1 % mod);",
			"\t\t}",
			"\t}",
			"\t",
			"\tstatic vector<int> multiply(vector<int> const& a, vector<int> const& b) {",
			"\t\tvector<int> fa(a), fb(b);",
			"\t\tint n = 1;",
			"\t\twhile (n < a.size() or n < b.size()) ",
			"\t\t\tn <<= 1;",
			"\t\tfa.resize(n);",
			"\t\tfb.resize(n);",
			"",
			"\t\tfwht(fa, false);",
			"\t\tfwht(fb, false);",
			"\t\tfor (int i = 0; i < n; i++)",
			"\t\t\tfa[i] = (1LL * fa[i] * fb[i] % mod);",
			"\t\tfwht(fa, true);",
			"",
			"\t\treturn fa;",
			"\t}",
			"};"
		],
		"description": "My Fast Walsh Hadamard Transform code."
	},


	"Number Theoretic Transform": {
		"prefix": "number-theoretic-transform",
		"body": [
			"class NTT",
			"{",
			"private:",
			"\tstatic const int mod = 998244353;    // 2^k * c + 1 (998244353 == 2^23 * 7 * 17 + 1)",
			"",
			"\t// Automatic finding of primitive root and nth root of unity currently works only for prime modules of the form 2^k * c + 1",
			"\t",
			"\tstatic const int primitive_root; // g",
			"\tstatic const int root;           // g^c modulo mod",
			"\tstatic const int root_1;         // root^-1 modulo mod",
			"\tstatic const int root_pw;        // 2^k",
			"",
			"\tstatic constexpr long long p (long long x, long long y)",
			"\t{",
			"\t\tlong long ans = 1;",
			"\t\twhile(y)",
			"\t\t{",
			"\t\t\tif(y & 1)",
			"\t\t\t\t(ans *= x) %= mod;",
			"\t\t\t(x *= x) %= mod;",
			"\t\t\ty /= 2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tstatic constexpr long long inv (long long x)",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"",
			"\tstatic constexpr int get_primitive_root()",
			"\t{",
			"\t\tconst int phi = mod - 1;",
			"\t\tint x = phi;",
			"\t\tint powers_to_be_checked[32] = {};",
			"\t\tint powers_to_be_checked_size = 0;",
			"\t\tfor(int i = 2; i * i <= x; i++)",
			"\t\t{",
			"\t\t\tpowers_to_be_checked[powers_to_be_checked_size] = phi / i;",
			"\t\t\tpowers_to_be_checked_size++;",
			"\t\t\twhile(x % i == 0)",
			"\t\t\t\tx /= i;",
			"\t\t}",
			"\t\tint num = 1;",
			"\t\tbool ok = false;",
			"\t\tdo",
			"\t\t{",
			"\t\t\tnum++;",
			"\t\t\tok = true;",
			"\t\t\tfor(int i = 0; i < powers_to_be_checked_size; i++)",
			"\t\t\t\tif(p(num, powers_to_be_checked[i]) == 1)",
			"\t\t\t\t{",
			"\t\t\t\t\tok = false;",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"\t\t} while(!ok);",
			"\t\treturn num;",
			"\t}",
			"",
			"\tstatic constexpr int get_root()",
			"\t{",
			"\t\tint c = mod - 1;",
			"\t\twhile(!(c & 1))",
			"\t\t\tc /= 2;",
			"\t\t// Cannot use primitive_root here directly, Codechef does not allow it.",
			"\t\t// Works on my local machine though.",
			"\t\treturn p(get_primitive_root(), c);",
			"\t}",
			"",
			"\tstatic constexpr int get_root_pw()",
			"\t{",
			"\t\tint two_k = 1, n = mod - 1;",
			"\t\twhile(!(n & 1))",
			"\t\t\ttwo_k *= 2, n /= 2;",
			"\t\treturn two_k;",
			"\t}",
			"",
			"\tstatic void ntt (vector<int> & a, bool invert)",
			"\t{",
			"\t\tint n = a.size();",
			"",
			"\t\tfor (int i = 1, j = 0; i < n; i++) {",
			"\t\t\tint bit = n >> 1;",
			"\t\t\tfor (; j & bit; bit >>= 1)",
			"\t\t\t\tj ^= bit;",
			"\t\t\tj ^= bit;",
			"",
			"\t\t\tif (i < j)",
			"\t\t\t\tswap(a[i], a[j]);",
			"\t\t}",
			"",
			"\t\tfor (int len = 2; len <= n; len <<= 1) {",
			"\t\t\tint wlen = invert ? root_1 : root;",
			"\t\t\tfor (int i = len; i < root_pw; i <<= 1)",
			"\t\t\t\twlen = (int)(1LL * wlen * wlen % mod);",
			"",
			"\t\t\tfor (int i = 0; i < n; i += len) {",
			"\t\t\t\tint w = 1;",
			"\t\t\t\tfor (int j = 0; j < len / 2; j++) {",
			"\t\t\t\t\tint u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);",
			"\t\t\t\t\ta[i+j] = u + v < mod ? u + v : u + v - mod;",
			"\t\t\t\t\ta[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;",
			"\t\t\t\t\tw = (int)(1LL * w * wlen % mod);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif (invert) {",
			"\t\t\tint n_1 = inv(n);",
			"\t\t\tfor (int & x : a)",
			"\t\t\t\tx = (int)(1LL * x * n_1 % mod);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tstatic vector<int> multiply(vector<int> fa, vector<int> fb) {",
			"\t\tint n = 1;",
			"\t\twhile (n < fa.size() + fb.size()) ",
			"\t\t\tn <<= 1;",
			"\t\tfa.resize(n);",
			"\t\tfb.resize(n);",
			"",
			"\t\tntt(fa, false);",
			"\t\tntt(fb, false);",
			"\t\tfor (int i = 0; i < n; i++)",
			"\t\t\tfa[i] = (1LL * fa[i] * fb[i] % mod);",
			"\t\tntt(fa, true);",
			"\t\treturn fa;",
			"\t}",
			"};",
			"const int NTT::primitive_root = NTT::get_primitive_root();",
			"const int NTT::root = NTT::get_root();",
			"const int NTT::root_1 = NTT::inv(root);",
			"const int NTT::root_pw = NTT::get_root_pw();"
		],
		"description": "My Number Theoretic Transform code"
	},


	"Fast Modular Exponentiation": {
		"prefix": "modexp",
		"body": [
			"namespace modexp",
			"{",
			"\tconst int default_mod = 1000000007;",
			"",
			"\tconstexpr long long p (long long x, long long y, int mod = default_mod)",
			"\t{",
			"\t\tlong long ans = 1;",
			"\t\twhile(y)",
			"\t\t{",
			"\t\t\tif(y & 1)",
			"\t\t\t\t(ans *= x) %= mod;",
			"\t\t\t(x *= x) %= mod;",
			"\t\t\ty /= 2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tconstexpr long long inv (const long long x, int mod = default_mod)",
			"\t{",
			"\t\treturn p (x, mod - 2, mod);",
			"\t}",
			"}",
			"using modexp::p;",
			"using modexp::inv;"
		],
		"description": "My fast modular exponentiation code"
	},

	
	"Fenwick Tree": {
		"prefix": "fenwick-tree",
		"body": [
			"template <class T = long long>",
			"class FenwickTree",
			"{",
			"private:",
			"\tvector<T> tree;",
			"\tconst T identity = 0;",
			"\tT merge (const T x, const T y)",
			"\t{",
			"\t\treturn x + y;",
			"\t}",
			"\tT merge_inverse (const T x, const T y)",
			"\t{",
			"\t\treturn x - y;",
			"\t}",
			"\t// index is 0-based",
			"\tT query_0_to_index (int index)",
			"\t{",
			"\t\tT ans = identity;",
			"\t\tindex++;",
			"\t\tfor(; index > 0; index -= index & -index)",
			"\t\t\tans = merge(ans, tree[index]);",
			"\t\treturn ans;",
			"\t}",
			"",
			"public:",
			"\tFenwickTree (const int size)",
			"\t{",
			"\t\ttree.resize(size + 1, identity);",
			"\t}",
			"\t// index is 0-based",
			"\tvoid update (int index, const T delta)",
			"\t{",
			"\t\tindex++;",
			"\t\tfor(; index < tree.size() ; index += index & -index)",
			"\t\t\ttree[index] = merge(tree[index], delta);",
			"\t}",
			"\t// index is 0-based",
			"\tT query (const int l, const int r)",
			"\t{",
			"\t\treturn merge_inverse(query_0_to_index(r), query_0_to_index(l-1));",
			"\t}",
			"};"
		],
		"description": "My Fenwick Tree class"
	},


	"Convex Hull": {
		"prefix": "convex-hull",
		"body": [
			"class Line",
			"{",
			"public:",
			"\t// Represents a line with the equation y = mx + c",
			"\tconst int m, c;",
			"\t// rightx is the x coordinate of the intersection point of the line",
			"\t// with the line just right to it in the Convex Hull.",
			"\tmutable float rightx;",
			"\tLine(const int _m, const int _c) : m(_m), c(_c) {}",
			"\tbool operator < (const Line& l) const { return m < l.m; }",
			"\tbool operator < (const float x) const { return rightx < x; }",
			"\t// intersectx handles the case of intersection of two parallel lines",
			"\t// for ConvexHull::isect as well.",
			"\tfloat intersectx(const Line& l) const { return float(c - l.c) / (l.m - m); }",
			"};",
			"",
			"class ConvexHull : private multiset<Line, less<>>",
			"{",
			"private:",
			"\tstatic constexpr float inf = numeric_limits<float>::infinity();",
			"\tbool isect(const iterator x, const iterator y) const",
			"\t{",
			"\t\tif (y == end()) { x->rightx = inf; return false; }",
			"\t\tx->rightx = x->intersectx(*y);",
			"\t\treturn x->rightx >= y->rightx;",
			"\t}",
			"public:",
			"\tvoid add_line(const int m, const int c)",
			"\t{",
			"\t\titerator y = insert(Line(m, c)), x = y++;",
			"\t\twhile (isect(x, y)) y = erase(y);",
			"\t\ty = x;",
			"\t\tif (x != begin() and isect(--x, y)) isect(x, y = erase(y));",
			"\t\twhile ((y = x) != begin() and (--x)->rightx >= y->rightx)",
			"\t\t\tisect(x, erase(y));",
			"\t}",
			"\tfloat query(const float x) const",
			"\t{",
			"\t\tassert(!empty());",
			"\t\tauto l = *lower_bound(x);",
			"\t\treturn l.m * x + l.c;",
			"\t}",
			"};"
		],
		"description": "Fully dynamic convex hull code"
	},


	"Undirected Graph": {
		"prefix": "undirected-graph",
		"body": [
			"class UndirectedGraph",
			"{",
			"private:",
			"\tconst vector<vector<int>> M;",
			"",
			"\tint diameter_helper(const int x, const int par, int &ans) const",
			"\t{",
			"\t\tpriority_queue<int, vector<int>, greater<int>> pq;",
			"\t\tpq.push(0);",
			"\t\tpq.push(0);",
			"\t\tfor(const int y : M[x])",
			"\t\t{",
			"\t\t\tif(y == par)",
			"\t\t\t\tcontinue;",
			"\t\t\tpq.push(diameter_helper(y, x, ans));",
			"\t\t\tpq.pop();",
			"\t\t}",
			"\t\tint cur_diameter = pq.top();",
			"\t\tpq.pop();",
			"\t\tcur_diameter += pq.top();",
			"\t\tans = max(ans, cur_diameter);",
			"\t\treturn 1 + pq.top();",
			"\t}",
			"",
			"public:",
			"\tUndirectedGraph(const vector<vector<int>> &_M) : M(_M) {}",
			"",
			"\tint diameter() const",
			"\t{",
			"\t\tint ans = 0;",
			"\t\tdiameter_helper(0, -1, ans);",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "Undirected graph operations"
	},


	"Get Primes": {
		"prefix": "get-primes-upto",
		"body": [
			"vector<int> get_primes_upto(int n)",
			"{",
			"\tvector<int> composite(n);",
			"\tcomposite[0] = 1;",
			"\tfor(int i = 2; i <= n; i++)",
			"\t{",
			"\t\tif(composite[i-1])",
			"\t\t\tcontinue;",
			"\t\tfor(int j = 2 * i; j <= n; j += i)",
			"\t\t\tcomposite[j-1] = 1;",
			"\t}",
			"\tvector<int> primes;",
			"\tfor(int i = 1; i <= n; i++)",
			"\t\tif(!composite[i-1])",
			"\t\t\tprimes.push_back(i);",
			"\treturn primes;",
			"}"
		],
		"description": "Get primes upto an integer n"
	},


	"Modular Polynomial": {
		"prefix": "polynomial-modular",
		"body": [
			"class Poly_modular",
			"{",
			"private:",
			"\tstatic const int default_mod = 1000000007;",
			"\tconst int mod;",
			"",
			"\tconstexpr long long p (long long x, long long y) const",
			"\t{",
			"\t\tlong long ans = 1;",
			"\t\twhile(y)",
			"\t\t{",
			"\t\t\tif(y & 1)",
			"\t\t\t{",
			"\t\t\t\t(ans *= x) %= mod;",
			"\t\t\t}",
			"\t\t\t(x *= x) %= mod;",
			"\t\t\ty /= 2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tconstexpr long long inv (const long long x) const",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"",
			"public:",
			"\tvector<long long> coeffs;",
			"",
			"\tPoly_modular(const int _mod = default_mod) : mod(_mod) {}",
			"\tPoly_modular(const vector<long long> &_coeffs, const int _mod = default_mod) : coeffs(_coeffs), mod(_mod) {}",
			"\tPoly_modular(const initializer_list<long long> &_coeffs, const int _mod = default_mod) : coeffs(_coeffs), mod(_mod) {}",
			"",
			"\tPoly_modular& operator *= (const Poly_modular& poly)",
			"\t{",
			"\t\tif(poly.coeffs.empty())",
			"\t\t{",
			"\t\t\tcoeffs.clear();",
			"\t\t\treturn *this;",
			"\t\t}",
			"\t\tint old_size = coeffs.size();",
			"\t\tcoeffs.resize(coeffs.size() + poly.coeffs.size() - 1);",
			"\t\tfor(int i = old_size - 1; i > -1; i--)",
			"\t\t{",
			"\t\t\tfor(int j = poly.coeffs.size() - 1; j > 0; j--)",
			"\t\t\t{",
			"\t\t\t\t(coeffs[i + j] += coeffs[i] * poly.coeffs[j] % h) %= h;",
			"\t\t\t}",
			"\t\t\t(coeffs[i] *= poly.coeffs[0]) %= h;",
			"\t\t}",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tPoly_modular operator * (const Poly_modular &poly) const",
			"\t{",
			"\t\treturn Poly_modular(*this) *= poly;",
			"\t}",
			"",
			"\tPoly_modular& operator *= (const long long c)",
			"\t{",
			"\t\treturn *this *= Poly_modular({c});",
			"\t}",
			"\t",
			"\tPoly_modular operator * (const long long c) const",
			"\t{",
			"\t\treturn Poly_modular(*this) *= c;",
			"\t}",
			"",
			"\tPoly_modular& operator /= (const long long c)",
			"\t{",
			"\t\treturn *this *= Poly_modular({inv(c)});",
			"\t}",
			"\t",
			"\tPoly_modular operator / (const long long c) const",
			"\t{",
			"\t\treturn Poly_modular(*this) /= c;",
			"\t}",
			"\t",
			"\tPoly_modular multiply (const Poly_modular &poly) const",
			"\t{",
			"\t\treturn *this * poly;",
			"\t}",
			"\t",
			"\tPoly_modular multiply (const long long c) const",
			"\t{",
			"\t\treturn *this * c;",
			"\t}",
			"\t",
			"\tPoly_modular divide (const long long c) const",
			"\t{",
			"\t\treturn *this / c;",
			"\t}",
			"",
			"\tlong long evaluate(long long x) const",
			"\t{",
			"\t\tlong long xp = 1, ans = 0;",
			"\t\tfor(long long c : coeffs)",
			"\t\t{",
			"\t\t\t(ans += c * xp % mod) %= mod;",
			"\t\t\t(xp *= x) %= mod;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tPoly_modular differentiate() const",
			"\t{",
			"\t\tvector<long long> d(coeffs);",
			"\t\tif(d.empty())",
			"\t\t{",
			"\t\t\treturn Poly_modular(mod);",
			"\t\t}",
			"\t\td.erase(d.begin());",
			"\t\tfor(int i = 0; i < d.size(); i++)",
			"\t\t{",
			"\t\t\t(d[i] *= i + 1) %= mod;",
			"\t\t}",
			"\t\treturn Poly_modular(d);",
			"\t}",
			"",
			"\tPoly_modular integrate() const",
			"\t{",
			"\t\tvector<long long> ig(coeffs);",
			"\t\tig.insert(ig.begin(), 0);",
			"\t\tfor(int i = 1; i < ig.size(); i++)",
			"\t\t{",
			"\t\t\t(ig[i] *= inv(i)) %= mod;",
			"\t\t}",
			"\t\treturn Poly_modular(ig);",
			"\t}",
			"};"
		],
		"description": "Modular polynomial class"
	},


	"Longest Increasing Subsequence": {
		"prefix": "longest-increasing-subsequence",
		"body": [
			"template <class Iterator, class Compare>",
			"int lis_length (const Iterator begin, const Iterator end, const Compare cmp)",
			"{",
			"\tusing T = typename iterator_traits<Iterator>::value_type;",
			"\tconst int len = end - begin;",
			"\t// dp[i] = (smallest element with which a list of subsequence of length i + 1 ends, is any such list attainable)",
			"\t// boolean value is required for using generic compare function",
			"\tvector<pair<T, bool>> dp(len, {T(), false});",
			"\tconst auto dp_cmp = [&cmp] (const pair<T, bool> &x, const pair<T, bool> &y) -> bool {",
			"\t\treturn (x.second == true and y.second == true ? cmp(x.first, y.first) : x.second);",
			"\t};",
			"\tfor (Iterator it = begin; it != end; it++)",
			"\t{",
			"\t\t*lower_bound(dp.begin(), dp.end(), make_pair(*it, true), dp_cmp) = {*it, true};",
			"\t}",
			"\treturn lower_bound(dp.begin(), dp.end(), make_pair(T(), false), dp_cmp) - dp.begin();",
			"}",
			"",
			"template <class Iterator>",
			"int lis_length (const Iterator begin, const Iterator end)",
			"{",
			"\tusing T = typename iterator_traits<Iterator>::value_type;",
			"\treturn lis_length(begin, end, less<T>());",
			"}"
		],
		"description": "Code for finding Longest Increasing Subsequence"
	},


	"Binomial Coefficients": {
		"prefix": "binomial-coefficients",
		"body": [
			"class ncr",
			"{",
			"private:",
			"\tstatic const int mod = 1000000007;",
			"\tstatic const int max_n = 300000;",
			"\tstatic bool initialized;",
			"",
			"\tstatic array<long long, max_n + 1> fact, inv_fact;",
			"",
			"\tstatic constexpr long long p (long long x, long long y)",
			"\t{",
			"\t\tlong long ans = 1;",
			"\t\twhile(y)",
			"\t\t{",
			"\t\t\tif(y & 1)",
			"\t\t\t\t(ans *= x) %= mod;",
			"\t\t\t(x *= x) %= mod;",
			"\t\t\ty /= 2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tstatic constexpr long long inv (long long x)",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"",
			"\tstatic void initialize()",
			"\t{",
			"\t\tfact[0] = inv_fact[0] = 1;",
			"\t\tfor(int i = 1; i <= max_n; i++)",
			"\t\t{",
			"\t\t\tfact[i] = fact[i-1] * i % mod;",
			"\t\t\tinv_fact[i] = inv(fact[i]);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tstatic long long get (const int n, const int r)",
			"\t{",
			"\t\tif(!initialized)",
			"\t\t{",
			"\t\t\tinitialized = true;",
			"\t\t\tinitialize();",
			"\t\t}",
			"\t\treturn fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod;",
			"\t}",
			"};",
			"array<long long, ncr::max_n + 1> ncr::fact = {};",
			"array<long long, ncr::max_n + 1> ncr::inv_fact = {};",
			"bool ncr::initialized = false;"
		],
		"description": "Code to calculate binomial coefficients"
	},


	"Graph": {
		"prefix": "graph",
		"body": [
			"class Graph",
			"{",
			"private:",
			"\tconst vector<vector<pair<int, long long>>> adj;",
			"",
			"\tconst vector<vector<pair<int, long long>>> get_weighted_adj(const vector<vector<int>> &unweighted_adj) const",
			"\t{",
			"\t\tvector<vector<pair<int, long long>>> weighted_adj(unweighted_adj.size());",
			"\t\tfor(int i = 0; i < unweighted_adj.size(); i++)",
			"\t\t{",
			"\t\t\tfor(int j = 0; j < unweighted_adj[i].size(); j++)",
			"\t\t\t{",
			"\t\t\t\tweighted_adj[i].push_back({unweighted_adj[i][j], 1LL});",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn weighted_adj;",
			"\t}",
			"",
			"public:",
			"\tGraph(const vector<vector<pair<int, long long>>> &_adj) : adj(_adj) {}",
			"\tGraph(const vector<vector<int>> &_adj) : adj(get_weighted_adj(_adj)) {}",
			"",
			"\tbool is_bipartite() const",
			"\t{",
			"\t\tvector<bool> vis(adj.size()), col(adj.size());",
			"\t\tfor(int i = 0; i < adj.size(); i++)",
			"\t\t{",
			"\t\t\tif(vis[i])",
			"\t\t\t\tcontinue;",
			"\t\t\tstack<int> st;",
			"\t\t\tvis[i] = true;",
			"\t\t\tst.push(i);",
			"\t\t\twhile(!st.empty())",
			"\t\t\t{",
			"\t\t\t\tconst int x = st.top();",
			"\t\t\t\tst.pop();",
			"\t\t\t\tfor(const pair<int, long long> &p : adj[x])",
			"\t\t\t\t{",
			"\t\t\t\t\tif(vis[p.first])",
			"\t\t\t\t\t{",
			"\t\t\t\t\t\tif(col[p.first] == col[x])",
			"\t\t\t\t\t\t\treturn false;",
			"\t\t\t\t\t\tcontinue;",
			"\t\t\t\t\t}",
			"\t\t\t\t\tcol[p.first] = !col[x];",
			"\t\t\t\t\tvis[p.first] = true;",
			"\t\t\t\t\tst.push(p.first);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn true;",
			"\t}",
			"",
			"\tlong long distance(const int source, const int destination) const",
			"\t{",
			"\t\tvector<bool> vis(adj.size());",
			"\t\tpriority_queue<pair<int, long long>, vector<pair<int, long long>>, greater<pair<int, long long>>> pq;",
			"\t\tpq.push({0, source});",
			"\t\twhile(!pq.empty())",
			"\t\t{",
			"\t\t\tconst long long w = pq.top().first;",
			"\t\t\tconst int x = pq.top().second;",
			"\t\t\tpq.pop();",
			"\t\t\tif(x == destination)",
			"\t\t\t\treturn w;",
			"\t\t\tif(vis[x])",
			"\t\t\t\tcontinue;",
			"\t\t\tvis[x] = true;",
			"\t\t\tfor(const pair<int, long long> &p : adj[x])",
			"\t\t\t\tpq.push({w + p.S, p.F});",
			"\t\t}",
			"\t\treturn numeric_limits<long long>::max();",
			"\t}",
			"};"
		],
		"description": "Graph class"
	},


	"Heavy Light Decomposition": {
		"prefix": "heavy-light-decomposition",
		"body": [
			"class HLD",
			"{",
			"private:",
			"\tvector<int> par, depth, seg_ind, head, head_par, parent_edge_weight;",
			"\tvector<SegTree<int>> seg;",
			"",
			"\tint dfs(const int x, const int d, const vector<vector<pair<int, int>>> &adj, vector<int> &heavy_child)",
			"\t{",
			"\t\tint size = 1;",
			"\t\tint heavy_size = 0;",
			"\t\tdepth[x] = d;",
			"\t\tfor(const pair<int, int> p : adj[x])",
			"\t\t{",
			"\t\t\tconst int y = p.first;",
			"\t\t\tconst int w = p.second;",
			"\t\t\tif(y == par[x])",
			"\t\t\t{",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tpar[y] = x;",
			"\t\t\tparent_edge_weight[y] = w;",
			"\t\t\tconst int y_size = dfs(y, d + 1, adj, heavy_child);",
			"\t\t\tif(y_size > heavy_size)",
			"\t\t\t{",
			"\t\t\t\theavy_size = y_size;",
			"\t\t\t\theavy_child[x] = y;",
			"\t\t\t}",
			"\t\t\tsize += y_size;",
			"\t\t}",
			"\t\treturn size;",
			"\t}",
			"",
			"\tvoid decompose(const int x, const int seg_index, const vector<vector<pair<int, int>>> &adj, const vector<int> &heavy_child, vector<vector<int>> &seg_vecs)",
			"\t{",
			"\t\tif(seg_index == seg_vecs.size())",
			"\t\t{",
			"\t\t\tseg_vecs.resize(seg_vecs.size() + 1);",
			"\t\t\thead.push_back(x);",
			"\t\t\thead_par.push_back(par[x]);",
			"\t\t}",
			"\t\tseg_ind[x] = seg_index;",
			"\t\tseg_vecs[seg_index].push_back(parent_edge_weight[x]);",
			"\t\tfor(const pair<int, int> p : adj[x])",
			"\t\t{",
			"\t\t\tconst int y = p.first;",
			"\t\t\tif(y == par[x])",
			"\t\t\t{",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tif(y == heavy_child[x])",
			"\t\t\t{",
			"\t\t\t\tdecompose(y, seg_index, adj, heavy_child, seg_vecs);",
			"\t\t\t}",
			"\t\t\telse",
			"\t\t\t{",
			"\t\t\t\tdecompose(y, seg_vecs.size(), adj, heavy_child, seg_vecs);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid create_segment_trees(vector<vector<int>> &seg_vecs)",
			"\t{",
			"\t\tfor(int i = 0; i < seg_vecs.size(); i++)",
			"\t\t{",
			"\t\t\tseg.emplace_back(seg_vecs[i]);",
			"\t\t}",
			"\t}",
			"",
			"\tint get_pos(const int x) const",
			"\t{",
			"\t\treturn depth[x] - depth[head[seg_ind[x]]];",
			"\t}",
			"",
			"public:",
			"\tHLD(const vector<vector<pair<int, int>>> &adj) : par(adj.size()), depth(adj.size()), seg_ind(adj.size()), parent_edge_weight(adj.size())",
			"\t{",
			"\t\tvector<int> heavy_child(adj.size(), -1);",
			"\t\tdfs(0, 0, adj, heavy_child);",
			"\t\tvector<vector<int>> seg_vecs;",
			"\t\tdecompose(0, 0, adj, heavy_child, seg_vecs);",
			"\t\tcreate_segment_trees(seg_vecs);",
			"\t}",
			"",
			"\tvoid update_node(const int x, const int val)",
			"\t{",
			"\t\tseg[seg_ind[x]].update(get_pos(x), val);",
			"\t}",
			"",
			"\tvoid update_edge(int x, int y, const int w)",
			"\t{",
			"\t\tif(par[y] == x)",
			"\t\t{",
			"\t\t\tswap(x, y);",
			"\t\t}",
			"\t\t// Now, par[x] == y",
			"\t\tseg[seg_ind[x]].update(get_pos(x), w);",
			"\t}",
			"",
			"\tint query(int x, int y, const bool edge_like = false)",
			"\t{",
			"\t\tint ans = INT_MIN;",
			"\t\twhile(seg_ind[x] != seg_ind[y])",
			"\t\t{",
			"\t\t\tif(depth[head[seg_ind[x]]] < depth[head[seg_ind[y]]])",
			"\t\t\t{",
			"\t\t\t\tswap(x, y);",
			"\t\t\t}",
			"\t\t\tans = max(ans, seg[seg_ind[x]].query(0, get_pos(x)));",
			"\t\t\tx = head_par[seg_ind[x]];",
			"\t\t}",
			"\t\tint l = get_pos(x), r = get_pos(y);",
			"\t\tif(l > r)",
			"\t\t{",
			"\t\t\tswap(l, r);",
			"\t\t}",
			"\t\tans = max(ans, seg[seg_ind[x]].query(l + edge_like, r));",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "Heavy Light Decomposition code"
	},

	
	"Segment Tree with Lazy Propagation": {
		"prefix": "segment-tree-lazy",
		"body": [
			"template <class seg_T = long long, class upd_T = long long>",
			"class SegTree",
			"{",
			"private:",
			"\tstatic const upd_T update_identity;",
			"\tseg_T merge_elem(const seg_T&, const seg_T&) const;",
			"\tupd_T merge_upd(const upd_T& upd1, const upd_T& upd2) const;",
			"\tseg_T update_elem(const seg_T& val, const upd_T& upd, const int num_elems) const;",
			"\tconst int underlying_array_size;",
			"\tvector<seg_T> seg_tree;",
			"\tvector<upd_T> lazy;",
			"\tvoid build(const int node, const int start, const int end, const vector<seg_T>& v)",
			"\t{",
			"\t\tif(start == end)",
			"\t\t{",
			"\t\t\tseg_tree[node] = v[start];",
			"\t\t}",
			"\t\telse",
			"\t\t{",
			"\t\t\tconst int mid = (start + end) / 2;",
			"\t\t\tbuild(2 * node + 1, start, mid, v);",
			"\t\t\tbuild(2 * node + 2, mid + 1, end, v);",
			"\t\t\tseg_tree[node] = merge_elem(seg_tree[2 * node + 1], seg_tree[2 * node + 2]);",
			"\t\t}",
			"\t}",
			"\tvoid update_range(const int node, const int start, const int end, const int l, const int r, const upd_T& val)",
			"\t{",
			"\t\tif(l <= start and end <= r)",
			"\t\t\tlazy[node] = merge_upd(lazy[node], val);",
			"\t\tif(lazy[node] != update_identity and start != end)",
			"\t\t{",
			"\t\t\tlazy[2 * node + 1] = merge_upd(lazy[2 * node + 1], lazy[node]);",
			"\t\t\tlazy[2 * node + 2] = merge_upd(lazy[2 * node + 2], lazy[node]);",
			"\t\t}",
			"\t\tif(end < l or r < start or (l <= start and end <= r))",
			"\t\t{",
			"\t\t\tseg_tree[node] = update_elem(seg_tree[node], lazy[node], end - start + 1);",
			"\t\t\tlazy[node] = update_identity;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tlazy[node] = update_identity;",
			"\t\tconst int mid = (start + end) / 2;",
			"\t\tupdate_range(2 * node + 1, start, mid, l, r, val);",
			"\t\tupdate_range(2 * node + 2, mid + 1, end, l, r, val);",
			"\t\tseg_tree[node] = merge_elem(seg_tree[2 * node + 1], seg_tree[2 * node + 2]);",
			"\t}",
			"\tseg_T query(const int node, const int start, const int end, const int l, const int r)",
			"\t{",
			"\t\tif(lazy[node] != update_identity)",
			"\t\t{",
			"\t\t\tif(start != end)",
			"\t\t\t{",
			"\t\t\t\tlazy[2 * node + 1] = merge_upd(lazy[2 * node + 1], lazy[node]);",
			"\t\t\t\tlazy[2 * node + 2] = merge_upd(lazy[2 * node + 2], lazy[node]);",
			"\t\t\t}",
			"\t\t\tseg_tree[node] = update_elem(seg_tree[node], lazy[node], end - start + 1);",
			"\t\t\tlazy[node] = update_identity;",
			"\t\t}",
			"\t\tif(l <= start and end <= r)",
			"\t\t\treturn seg_tree[node];",
			"\t\tconst int mid = (start + end) / 2;",
			"\t\tif(r <= mid)",
			"\t\t\treturn query(2 * node + 1, start, mid, l, r);",
			"\t\telse if(l > mid)",
			"\t\t\treturn query(2 * node + 2, mid + 1, end, l, r);",
			"\t\treturn merge_elem(",
			"\t\t\tquery(2 * node + 1, start, mid, l, r),",
			"\t\t\tquery(2 * node + 2, mid + 1, end, l, r)",
			"\t\t);",
			"\t}",
			"",
			"public:",
			"\tSegTree(const int n, const seg_T val)",
			"\t\t: underlying_array_size(n),",
			"\t\tseg_tree(4 * underlying_array_size, val),",
			"\t\tlazy(4 * underlying_array_size, update_identity)",
			"\t{",
			"\t\tconst vector<seg_T> v(underlying_array_size, val);",
			"\t\tbuild(0, 0, underlying_array_size - 1, v);",
			"\t}",
			"\tSegTree(const vector<seg_T>& v)",
			"\t\t: underlying_array_size(v.size()),",
			"\t\tseg_tree(4 * underlying_array_size),",
			"\t\tlazy(4 * underlying_array_size, update_identity)",
			"\t{",
			"\t\tbuild(0, 0, underlying_array_size - 1, v);",
			"\t}",
			"\tint size() const",
			"\t{",
			"\t\treturn underlying_array_size;",
			"\t}",
			"\tvoid update_range(const int l, const int r, const upd_T& val)",
			"\t{",
			"\t\tupdate_range(0, 0, underlying_array_size - 1, l, r, val);",
			"\t}",
			"\tseg_T query(const int l, const int r)",
			"\t{",
			"\t\treturn query(0, 0, underlying_array_size - 1, l, r);",
			"\t}",
			"};",
			"",
			"// Modify as required",
			"",
			"template <class seg_T, class upd_T>",
			"const upd_T SegTree<seg_T, upd_T>::update_identity = 0;",
			"",
			"template <class seg_T, class upd_T>",
			"seg_T SegTree<seg_T, upd_T>::merge_elem(const seg_T& val1, const seg_T& val2) const",
			"{",
			"\treturn max(val1, val2);",
			"}",
			"",
			"template <class seg_T, class upd_T>",
			"upd_T SegTree<seg_T, upd_T>::merge_upd(const upd_T& upd1, const upd_T& upd2) const",
			"{",
			"\treturn upd1 + upd2;",
			"}",
			"",
			"template <class seg_T, class upd_T>",
			"seg_T SegTree<seg_T, upd_T>::update_elem(const seg_T& val, const upd_T& upd, const int num_elems) const",
			"{",
			"\treturn val + upd;",
			"}"
		],
		"description": "My code for a segment tree with lazy propagation"
	},


	"Modular Integer Class": {
		"prefix": "modular-integer",
		"body": [
			"${1:modexp}",
			"",
			"template <const long long mod = 1000000007LL>",
			"class modular",
			"{",
			"private:",
			"\tlong long val;",
			"",
			"public:",
			"\tmodular() : val(0) {}",
			"\tmodular(long long _val) : val((_val %= mod) < 0 ? _val + mod : _val) {}",
			"",
			"\tlong long value() const { return val; }",
			"",
			"\tmodular<mod>& operator+=(const modular<mod>& op)",
			"\t{",
			"\t\tval += op.value();",
			"\t\tif(val >= mod)",
			"\t\t{",
			"\t\t\tval -= mod;",
			"\t\t}",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tmodular<mod>& operator-=(const modular<mod>& op)",
			"\t{",
			"\t\tval -= op.value();",
			"\t\tif(val < 0)",
			"\t\t{",
			"\t\t\tval += mod;",
			"\t\t}",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tmodular<mod>& operator*=(const modular<mod>& op)",
			"\t{",
			"\t\t(val *= op.value()) %= mod;",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tmodular<mod>& operator/=(const modular<mod>& op)",
			"\t{",
			"\t\treturn *this *= inv(op.value(), mod);",
			"\t}",
			"",
			"\tmodular<mod> operator-() const",
			"\t{",
			"\t\treturn modular<mod>(-val);",
			"\t}",
			"",
			"\tbool operator==(const modular<mod>& op) const",
			"\t{",
			"\t\treturn val == op.value();",
			"\t}",
			"",
			"\tfriend modular<mod> operator+(const modular<mod>& op, const modular<mod>& op2)",
			"\t{",
			"\t\treturn modular<mod>(op) += op2;",
			"\t}",
			"",
			"\tfriend modular<mod> operator-(const modular<mod>& op, const modular<mod>& op2)",
			"\t{",
			"\t\treturn modular<mod>(op) -= op2;",
			"\t}",
			"",
			"\tfriend modular<mod> operator*(const modular<mod>& op, const modular<mod>& op2)",
			"\t{",
			"\t\treturn modular<mod>(op) *= op2;",
			"\t}",
			"",
			"\tfriend modular<mod> operator/(const modular<mod>& op, const modular<mod>& op2)",
			"\t{",
			"\t\treturn modular<mod>(op) /= op2;",
			"\t}",
			"",
			"\tfriend ostream& operator<<(const ostream& out, const modular<mod>& op)",
			"\t{",
			"\t\treturn out << op.value();",
			"\t}",
			"};"
		],
		"description": "Modular Integer Class"
	},


	"Gauss Jordan Elimination": {
		"prefix": "gauss-jordan-elimination",
		"body": [
			"template <class T = double>",
			"class GaussJordanElimination",
			"{",
			"private:",
			"\tvector<T> ans;",
			"\tenum class NumSolutions { unique_solution, no_solution, infinitely_many_solutions } num_solutions = NumSolutions::unique_solution;",
			"",
			"\ttemplate <class U = T>",
			"\ttypename enable_if<is_floating_point<U>::value, bool>::type is_zero(const T& val)",
			"\t{",
			"\t\tconstexpr T EPS = 1e-9;",
			"\t\treturn val < EPS and val > -EPS;",
			"\t}",
			"",
			"\ttemplate <class U = T>",
			"\ttypename enable_if<!is_floating_point<U>::value, bool>::type is_zero(const T& val)",
			"\t{",
			"\t\treturn val == 0;",
			"\t}",
			"",
			"\t// This is a heuristic function, which greatly decreases the",
			"\t// chances of overflow in later stages of the algorithm",
			"\ttemplate <class U = T>",
			"\ttypename enable_if<is_floating_point<U>::value, int>::type get_pivot(const int row, const vector<vector<T>>& coeffs)",
			"\t{",
			"\t\tint ind = row;",
			"\t\tfor(int i = row + 1; i < coeffs.size(); i++)",
			"\t\t{",
			"\t\t\tif(coeffs[i][row] > coeffs[ind][row])",
			"\t\t\t{",
			"\t\t\t\tind = i;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn ind;",
			"\t}",
			"",
			"\ttemplate <class U = T>",
			"\ttypename enable_if<!is_floating_point<U>::value, int>::type get_pivot(const int row, const vector<vector<T>>& coeffs)",
			"\t{",
			"\t\treturn row;",
			"\t}",
			"",
			"public:",
			"\t// Currently, coeffs must be a square matrix",
			"\tGaussJordanElimination(vector<vector<T>> coeffs, vector<T>& vals) : ans(vals)",
			"\t{",
			"\t\tfor(const vector<T>& row : coeffs)",
			"\t\t{",
			"\t\t\tassert(row.size() == coeffs.size());",
			"\t\t}",
			"\t\tfor(int row = 0; row < coeffs.size(); row++)",
			"\t\t{",
			"\t\t\t// Find pivot",
			"\t\t\tconst int pivot = get_pivot(row, coeffs);",
			"",
			"\t\t\t// Swap current row with pivot",
			"\t\t\tif(pivot != row)",
			"\t\t\t{",
			"\t\t\t\tfor(int col = row; col < coeffs[0].size(); col++)",
			"\t\t\t\t{",
			"\t\t\t\t\tswap(coeffs[row][col], coeffs[pivot][col]);",
			"\t\t\t\t}",
			"\t\t\t\tswap(ans[row], ans[pivot]);",
			"\t\t\t}",
			"",
			"\t\t\tif(is_zero(coeffs[row][row]))",
			"\t\t\t{",
			"\t\t\t\tif(is_zero(ans[row]))",
			"\t\t\t\t{",
			"\t\t\t\t\tnum_solutions = NumSolutions::infinitely_many_solutions;",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\t}",
			"\t\t\t\telse",
			"\t\t\t\t{",
			"\t\t\t\t\tnum_solutions = NumSolutions::no_solution;",
			"\t\t\t\t\treturn;",
			"\t\t\t\t}",
			"\t\t\t}",
			"",
			"\t\t\t// Divide coeffs[row] by coeffs[row][row]",
			"\t\t\tconst T d = coeffs[row][row];",
			"\t\t\tfor(int col = row; col < coeffs[0].size(); col++)",
			"\t\t\t{",
			"\t\t\t\tcoeffs[row][col] /= d;",
			"\t\t\t}",
			"\t\t\tans[row] /= d;",
			"",
			"\t\t\t// Iterate over other rows r != row and get rid of coeffs[r][row] using coeffs[row][row]",
			"\t\t\tfor(int r = 0; r < coeffs.size(); r++)",
			"\t\t\t{",
			"\t\t\t\tif(r == row)",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\tconst T factor = coeffs[r][row];",
			"\t\t\t\tfor(int c = row; c < coeffs[0].size(); c++)",
			"\t\t\t\t{",
			"\t\t\t\t\tcoeffs[r][c] -= coeffs[row][c] * factor;",
			"\t\t\t\t}",
			"\t\t\t\tans[r] -= ans[row] * factor;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tbool has_unique_solution()",
			"\t{",
			"\t\treturn num_solutions == NumSolutions::unique_solution;",
			"\t}",
			"",
			"\tbool has_no_solution()",
			"\t{",
			"\t\treturn num_solutions == NumSolutions::no_solution;",
			"\t}",
			"",
			"\tbool has_infinite_solutions()",
			"\t{",
			"\t\treturn num_solutions == NumSolutions::infinitely_many_solutions;",
			"\t}",
			"",
			"\tconst vector<T>& get_ans()",
			"\t{",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "Gauss Jordan Elimination"
	},


	"Longest Proper Suffix that is also a Prefix": {
		"prefix": "longest-proper-suffix-that-is-also-a-prefix",
		"body": [
			"vector<int> get_lps(const string& s)",
			"{",
			"\tvector<int> lps(s.size());",
			"\tint l = 0;",
			"\tfor(int i = 1; i < s.size(); i++)",
			"\t{",
			"\t\twhile(s[l] != s[i] and l != 0)",
			"\t\t{",
			"\t\t\tl = lps[l - 1];",
			"\t\t}",
			"\t\tif(!(l == 0 and s[l] != s[i]))",
			"\t\t{",
			"\t\t\tl++;",
			"\t\t}",
			"\t\tlps[i] = l;",
			"\t}",
			"\treturn lps;",
			"}"
		],
		"description": "Code to find longest proper suffix that is also a prefix for all prefixes of a string"
	},


	"Knuth Morris Pratt": {
		"prefix": "knuth-morris-pratt",
		"body": [
			"${1:longest-proper-suffix-that-is-also-a-prefix}",
			"",
			"class KMP",
			"{",
			"private:",
			"\tconst string pattern;",
			"\tconst vector<int> lps;",
			"",
			"public:",
			"\tKMP(const string &_pattern) : pattern(_pattern), lps(get_lps(pattern)) {}",
			"",
			"\tvector<int> search(const string &s) const",
			"\t{",
			"\t\tvector<int> ans;",
			"\t\tint l = 0;",
			"\t\tfor(int i = 0; i < s.size(); i++)",
			"\t\t{",
			"\t\t\twhile(l != 0 and (l == pattern.size() or s[i] != pattern[l]))",
			"\t\t\t{",
			"\t\t\t\tl = lps[l - 1];",
			"\t\t\t}",
			"\t\t\tif(s[i] == pattern[l])",
			"\t\t\t{",
			"\t\t\t\tl++;",
			"\t\t\t}",
			"\t\t\tif(l == pattern.size())",
			"\t\t\t{",
			"\t\t\t\tans.push_back(i - l + 1);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "Knuth Morris Pratt"
	},


	"Directed Graph": {
		"prefix": "directed-graph",
		"body": [
			"class DirectedGraph",
			"{",
			"private:",
			"\tconst vector<vector<int>> adj;",
			"",
			"\tbool cycle_check_dfs(int x, vector<int>& inpath, vector<int>& vis) const",
			"\t{",
			"\t\tvis[x] = true;",
			"\t\tinpath[x] = true;",
			"\t\tfor(int y : adj[x])",
			"\t\t{",
			"\t\t\tif(inpath[y] or (!vis[y] and cycle_check_dfs(y, inpath, vis)))",
			"\t\t\t{",
			"\t\t\t\treturn true;",
			"\t\t\t}",
			"\t\t}",
			"\t\tinpath[x] = false;",
			"\t\treturn false;",
			"\t}",
			"",
			"\tvoid topological_sort_dfs(int source, vector<int>& vis, stack<int>& rev_stack)",
			"\t{",
			"\t\tvis[source] = 1;",
			"\t\tfor(int next : adj[source])",
			"\t\t{",
			"\t\t\tif(!vis[next])",
			"\t\t\t{",
			"\t\t\t\ttopological_sort_dfs(next, vis, rev_stack);",
			"\t\t\t}",
			"\t\t}",
			"\t\trev_stack.push(source);",
			"\t}",
			"",
			"public:",
			"\tDirectedGraph(const vector<vector<int>> &_adj) : adj(_adj) {}",
			"",
			"\tbool contains_cycle() const",
			"\t{",
			"\t\tvector<int> inpath(adj.size()), vis(adj.size());",
			"\t\tfor(int i = 0; i < adj.size(); i++)",
			"\t\t{",
			"\t\t\tif(!vis[i] and cycle_check_dfs(i, inpath, vis))",
			"\t\t\t{",
			"\t\t\t\treturn true;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn false;",
			"\t}",
			"",
			"\t// Note that this ordering is not compatible for finding strongly connected components.",
			"\t// This method expects a Directed Acyclic Graph.",
			"\tvector<int> topological_sort()",
			"\t{",
			"\t\tvector<int> vis(adj.size());",
			"\t\tstack<int> rev_stack;",
			"\t\tfor(int i = 0; i < adj.size(); i++)",
			"\t\t{",
			"\t\t\tif(!vis[i])",
			"\t\t\t{",
			"\t\t\t\ttopological_sort_dfs(i, vis, rev_stack);",
			"\t\t\t}",
			"\t\t}",
			"\t\tvector<int> ordering;",
			"\t\twhile(!rev_stack.empty())",
			"\t\t{",
			"\t\t\tordering.push_back(rev_stack.top());",
			"\t\t\trev_stack.pop();",
			"\t\t}",
			"\t\treturn ordering;",
			"\t}",
			"};"
		],
		"description": "Directed graph operations"
	},

	
	"Lowest Common Ancestor": {
		"prefix": "lowest-common-ancestor",
		"body": [
			"class LCA",
			"{",
			"private:",
			"\tstatic constexpr int max_power_of_2 = 19;",
			"\tvector<int> levels;",
			"\tarray<vector<int>, max_power_of_2 + 1> sp;",
			"",
			"\tvoid dfs (const int x, const int par, const int lev, const vector<vector<int>> &adj)",
			"\t{",
			"\t\tsp[0][x] = par;",
			"\t\tlevels[x] = lev;",
			"\t\tfor(const int y : adj[x])",
			"\t\t{",
			"\t\t\tif(sp[0][y] != -1) continue;",
			"\t\t\tdfs(y, x, lev + 1, adj);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tLCA (const vector<vector<int>> &adj) : levels(adj.size())",
			"\t{",
			"\t\tsp[0].resize(adj.size(), -1);",
			"\t\tfor(vector<int> &x : sp)",
			"\t\t{",
			"\t\t\tx.resize(adj.size());",
			"\t\t}",
			"\t\tdfs(0, 0, 0, adj);",
			"\t\tfor (int i = 1; i < max_power_of_2 + 1; i++)",
			"\t\t{",
			"\t\t\tfor (int j = 0; j < adj.size(); j++)",
			"\t\t\t{",
			"\t\t\t\tsp[i][j] = sp[i-1][sp[i-1][j]];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tint lift (int x, int d) const",
			"\t{",
			"\t\tfor (int i = max_power_of_2; i > -1; i--)",
			"\t\t{",
			"\t\t\tif(d >= 1 << i)",
			"\t\t\t{",
			"\t\t\t\td -= 1 << i;",
			"\t\t\t\tx = sp[i][x];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn x;",
			"\t}",
			"",
			"\tint lca (int x, int y) const",
			"\t{",
			"\t\tif(levels[x] < levels[y])",
			"\t\t{",
			"\t\t\tswap(x, y);",
			"\t\t}",
			"\t\tx = lift(x, levels[x] - levels[y]);",
			"\t\tfor (int i = max_power_of_2; i > -1; i--)",
			"\t\t{",
			"\t\t\tif (sp[i][x] != sp[i][y])",
			"\t\t\t{",
			"\t\t\t\tx = sp[i][x];",
			"\t\t\t\ty = sp[i][y];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn (x == y ? x : sp[0][x]);",
			"\t}",
			"",
			"\tint dist (const int x, const int y) const",
			"\t{",
			"\t\tconst int l = lca(x, y);",
			"\t\treturn levels[x] - levels[l] + levels[y] - levels[l];",
			"\t}",
			"",
			"\tint level(const int x) const",
			"\t{",
			"\t\treturn levels[x];",
			"\t}",
			"};"
		],
		"description": "Lowest Common Ancestor class"
	},


	"Greatest Common Divisor": {
		"prefix": "greatest-common-divisor",
		"body": [
			"long long gcd (long long a, long long b)",
			"{",
			"\twhile(b != 0)",
			"\t{",
			"\t\ta %= b;",
			"\t\tswap(a, b);",
			"\t}",
			"\treturn a;",
			"}"
		],
		"description": "Greatest Common Divisor"
	},


	"Extended Euclidean Algorithm": {
		"prefix": "extended-euclidean-algorithm",
		"body": [
			"/* a * x + b * y = gcd(a, b) */",
			"long long extgcd (long long a, long long b, long long& x, long long& y)",
			"{",
			"\tif(b == 0)",
			"\t{",
			"\t\tx = 1;",
			"\t\ty = 0;",
			"\t\treturn a;",
			"\t}",
			"\tlong long gcd = extgcd(b, a % b, y, x);",
			"\ty -= a / b * x;",
			"\treturn gcd;",
			"}"
		],
		"description": "Extended Euclidean Algorithm"
	},


	"Chinese Remainder Theorem": {
		"prefix": "chinese-remainder-theorem",
		"body": [
			"${1:extended-euclidean-algorithm}",
			"",
			"class ChineseRemainderTheorem",
			"{",
			"private:",
			"\tbool ans_exists = true;",
			"\tlong long ans_value = 0, ans_module = 1;",
			"\t",
			"public:",
			"\t/* Adds constraint: ans = value (mod module) */",
			"\tvoid add(const long long value, const long long module)",
			"\t{",
			"\t\tif (!ans_exists)",
			"\t\t{",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tlong long x, y;",
			"\t\t/* ans_module * x + module * y = g */",
			"\t\tconst long long g = extgcd(ans_module, module, x, y);",
			"\t\tconst long long rhs = value - ans_value;",
			"\t\tif (rhs % g != 0)",
			"\t\t{",
			"\t\t\tans_exists = false;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tconst long long f = rhs / g;",
			"\t\t/* ans_module * x + ans_value = module * y + value */",
			"\t\t/* ans_module * x - module * y = value - ans_value */",
			"\t\tx *= f;",
			"\t\ty *= f;",
			"\t\tconst long long lcm = ans_module * module / g;",
			"\t\tconst long long step = lcm / ans_module;",
			"\t\tx %= step;",
			"\t\tif (x < 0)",
			"\t\t{",
			"\t\t\tx += step;",
			"\t\t}",
			"\t\tans_value = ans_module * x + ans_value;",
			"\t\tans_module = lcm;",
			"\t}",
			"",
			"\tbool has_solution() const",
			"\t{",
			"\t\treturn ans_exists;",
			"\t}",
			"",
			"\tlong long value() const",
			"\t{",
			"\t\treturn ans_value;",
			"\t}",
			"",
			"\tlong long lcm() const",
			"\t{",
			"\t\treturn ans_module;",
			"\t}",
			"};"
		],
		"description": "Chinese Remainder Theorem"
	},


	"Get Prime Factors": {
		"prefix": "get-prime-factors",
		"body": [
			"std::vector<std::pair<int, int>> get_prime_factors(int n)",
			"{",
			"\tstd::vector<std::pair<int, int>> ans;",
			"\tfor(int i = 2; i * i <= n; i++)",
			"\t{",
			"\t\tif(n % i == 0)",
			"\t\t{",
			"\t\t\tint cnt = 0;",
			"\t\t\twhile(n % i == 0)",
			"\t\t\t{",
			"\t\t\t\tn /= i;",
			"\t\t\t\tcnt++;",
			"\t\t\t}",
			"\t\t\tans.push_back({i, cnt});",
			"\t\t}",
			"\t}",
			"\tif(n != 1)",
			"\t{",
			"\t\tans.push_back({n, 1});",
			"\t}",
			"\treturn ans;",
			"}"
		],
		"description": "Get Prime Factors"
	},


	"Bipartite Matching": {
		"prefix": "bipartite-matching",
		"body": [
			"${1:max-flow}",
			"",
			"class BipartiteMatching : private MaxFlow",
			"{",
			"private:",
			"\tconst int n, m;",
			"",
			"public:",
			"\tBipartiteMatching(const int n, const int m) : MaxFlow(n + m + 2), n(n), m(m)",
			"\t{",
			"\t\tfor(int i = 1; i <= n; i++)",
			"\t\t{",
			"\t\t\tMaxFlow::add_edge(0, i, 1);",
			"\t\t}",
			"\t\tfor(int i = n + 1; i < n + 1 + m; i++)",
			"\t\t{",
			"\t\t\tMaxFlow::add_edge(i, n + m + 1, 1);",
			"\t\t}",
			"\t}",
			"",
			"\tvoid add_edge(const int ind1, const int ind2)",
			"\t{",
			"\t\tMaxFlow::add_edge(1 + ind1, 1 + n + ind2, 1);",
			"\t}",
			"",
			"\tstd::vector<std::pair<int, int>> maximal_matching()",
			"\t{",
			"\t\tmaxflow(0, n + m + 1);",
			"\t\tstd::vector<std::pair<int, int>> ans;",
			"\t\tfor(unsigned i = 2 * (n + m); i < edges.size(); i += 2)",
			"\t\t{",
			"\t\t\tif(edges[i].capacity == 0)",
			"\t\t\t{",
			"\t\t\t\tans.push_back({edges[i ^ 1].to - 1, edges[i].to - 1 - n});",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "Bipartite Matching"
	},
	

	"Max Flow": {
		"prefix": "max-flow",
		"body": [
			"/* Implements Dinic's Algorithm */",
			"class MaxFlow",
			"{",
			"private:",
			"\tstruct FlowEdge",
			"\t{",
			"\t\tconst int to;",
			"\t\tlong long capacity;",
			"\t\tFlowEdge(const int to, const long long capacity) : to(to), capacity(capacity) {}",
			"\t};",
			"",
			"\tstd::vector<std::vector<int>> adj;",
			"\tstd::vector<int> level;",
			"",
			"\tbool level_bfs(const int source, const int sink)",
			"\t{",
			"\t\tlevel = std::vector<int>(adj.size(), -1);",
			"\t\tstd::queue<int> bfs_queue;",
			"\t\tlevel[source] = 0;",
			"\t\tbfs_queue.push(source);",
			"\t\twhile (!bfs_queue.empty())",
			"\t\t{",
			"\t\t\tconst int node = bfs_queue.front();",
			"\t\t\tbfs_queue.pop();",
			"\t\t\tfor (const int edge_ind : adj[node])",
			"\t\t\t{",
			"\t\t\t\tconst int to = edges[edge_ind].to;",
			"\t\t\t\tconst long long capacity = edges[edge_ind].capacity;",
			"\t\t\t\tif (capacity == 0 or level[to] != -1)",
			"\t\t\t\t{",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\t}",
			"\t\t\t\tlevel[to] = level[node] + 1;",
			"\t\t\t\tbfs_queue.push(to);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn level[sink] != -1;",
			"\t}",
			"",
			"\tlong long augment_flow(const int source, const int sink)",
			"\t{",
			"\t\tstd::stack<std::pair<int, long long>> dfs_stack;",
			"\t\tstd::vector<int> par_edge_inds(adj.size(), -1);",
			"\t\tdfs_stack.push({source, std::numeric_limits<long long>::max()});",
			"\t\twhile (!dfs_stack.empty() and dfs_stack.top().first != sink)",
			"\t\t{",
			"\t\t\tconst int cur = dfs_stack.top().first;",
			"\t\t\tconst long long flow = dfs_stack.top().second;",
			"\t\t\tdfs_stack.pop();",
			"\t\t\tfor (const int edge_ind : adj[cur])",
			"\t\t\t{",
			"\t\t\t\tconst int to = edges[edge_ind].to;",
			"\t\t\t\tconst long long capacity = edges[edge_ind].capacity;",
			"\t\t\t\tif (capacity == 0 or level[to] != level[cur] + 1 or par_edge_inds[to] != -1)",
			"\t\t\t\t{",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\t}",
			"\t\t\t\tpar_edge_inds[to] = edge_ind;",
			"\t\t\t\tdfs_stack.push({to, std::min(flow, capacity)});",
			"\t\t\t}",
			"\t\t}",
			"\t\tconst long long flow = (dfs_stack.empty() ? 0 : dfs_stack.top().second);",
			"\t\tif (!dfs_stack.empty())",
			"\t\t{",
			"\t\t\tint node = sink;",
			"\t\t\twhile (node != source)",
			"\t\t\t{",
			"\t\t\t\tconst int par_edge_ind = par_edge_inds[node];",
			"\t\t\t\tedges[par_edge_ind].capacity -= flow;",
			"\t\t\t\tedges[par_edge_ind ^ 1].capacity += flow;",
			"\t\t\t\tnode = edges[par_edge_ind ^ 1].to;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn flow;",
			"\t}",
			"",
			"protected:",
			"\tstd::vector<FlowEdge> edges;",
			"",
			"public:",
			"\tMaxFlow(const int n) : adj(n) {}",
			"",
			"\tvoid add_edge(const int from, const int to, const long long capacity)",
			"\t{",
			"\t\tadj[from].push_back(edges.size());",
			"\t\tedges.emplace_back(to, capacity);",
			"\t\tadj[to].push_back(edges.size());",
			"\t\tedges.emplace_back(from, 0);",
			"\t}",
			"",
			"\tlong long maxflow(const int source, const int sink)",
			"\t{",
			"\t\tlong long total_flow = 0;",
			"\t\twhile (level_bfs(source, sink))",
			"\t\t{",
			"\t\t\twhile (const long long flow = augment_flow(source, sink))",
			"\t\t\t{",
			"\t\t\t\ttotal_flow += flow;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn total_flow;",
			"\t}",
			"",
			"\tlong long maxflow(const int source, const int sink, std::vector<std::vector<std::pair<int, int>>>& flow_graph)",
			"\t{",
			"\t\tlong long flow = maxflow(source, sink);",
			"\t\tflow_graph.clear();",
			"\t\tflow_graph.resize(adj.size());",
			"\t\tfor(unsigned i = 0; i < edges.size(); i += 2)",
			"\t\t{",
			"\t\t\tif(edges[i ^ 1].capacity != 0)",
			"\t\t\t{",
			"\t\t\t\tflow_graph[edges[i ^ 1].to].push_back({edges[i].to, edges[i ^ 1].capacity});",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn flow;",
			"\t}",
			"",
			"\tstd::vector<std::pair<int, int>> mincut_edges(const int source, const int sink)",
			"\t{",
			"\t\tmaxflow(source, sink);",
			"\t\tstd::vector<bool> vis(adj.size());",
			"\t\tstd::stack<int> dfs_stack;",
			"\t\tdfs_stack.push(source);",
			"\t\tvis[source] = true;",
			"\t\twhile(!dfs_stack.empty())",
			"\t\t{",
			"\t\t\tconst int cur = dfs_stack.top();",
			"\t\t\tdfs_stack.pop();",
			"\t\t\tfor(const int edge_ind : adj[cur])",
			"\t\t\t{",
			"\t\t\t\tif(edges[edge_ind].capacity != 0 and !vis[edges[edge_ind].to])",
			"\t\t\t\t{",
			"\t\t\t\t\tvis[edges[edge_ind].to] = true;",
			"\t\t\t\t\tdfs_stack.push(edges[edge_ind].to);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tstd::vector<std::pair<int, int>> ans;",
			"\t\tfor(unsigned i = 0; i < edges.size(); i += 2)",
			"\t\t{",
			"\t\t\tif(vis[edges[i ^ 1].to] and !vis[edges[i].to])",
			"\t\t\t{",
			"\t\t\t\tans.push_back({edges[i ^ 1].to, edges[i].to});",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tint size() const {",
			"\t\treturn adj.size();",
			"\t}",
			"};"
		],
		"description": "Max Flow"
	},

	
	"Template for Competitive Programming": {
		"prefix": "mytemplate",
		"body": [
			"#include <algorithm>",
			"#include <array>",
			"#include <bitset>",
			"#include <cassert>",
			"#include <cfloat>",
			"#include <chrono>",
			"#include <climits>",
			"#include <cmath>",
			"#include <cstdio>",
			"#include <deque>",
			"#include <iomanip>",
			"#include <iostream>",
			"#include <map>",
			"#include <numeric>",
			"#include <optional>",
			"#include <queue>",
			"#include <random>",
			"#include <set>",
			"#include <sstream>",
			"#include <stack>",
			"#include <type_traits>",
			"#include <unordered_map>",
			"#include <unordered_set>",
			"#include <vector>",
			"",
			"template <class T1, class T2>",
			"std::istream& operator >> (std::istream& in, std::pair<T1, T2> &p) {",
			"\treturn in >> p.first >> p.second;",
			"}",
			"",
			"template <class Container, class ElemType = typename Container::value_type, class = typename std::enable_if<not std::is_same<Container, std::string>::value>::type>",
			"std::istream& operator >> (std::istream& in, Container& container) {",
			"\tfor (ElemType &x : container) {",
			"\t\tin >> x;",
			"\t}",
			"\treturn in;",
			"}",
			"",
			"template <class T1, class T2>",
			"std::ostream& operator << (std::ostream& out, const std::pair <T1, T2> p) {",
			"\treturn out << '(' << p.first << ',' << p.second << ')';",
			"}",
			"",
			"template <class, class = void>",
			"constexpr char ContainerPrintSeparator = ' ';",
			"",
			"template <class ElemType>",
			"constexpr char ContainerPrintSeparator<ElemType, std::void_t<typename ElemType::value_type>> = '\\n';",
			"",
			"template <class Container, class ElemType = typename Container::value_type, class = typename std::enable_if<not std::is_same<Container, std::string>::value>::type>",
			"std::ostream& operator << (std::ostream& out, const Container& container) {",
			"\tfor (const ElemType &x : container) {",
			"\t\tout << x << ContainerPrintSeparator<ElemType>;",
			"\t}",
			"\treturn out;",
			"}",
			"",
			"using ll   = long long;",
			"using pii  = std::pair<int, int>;",
			"using pll  = std::pair<long long, long long>;",
			"using vi   = std::vector<int>;",
			"using vl   = std::vector<long long>;",
			"using vvi  = std::vector<std::vector<int>>;",
			"using vvl  = std::vector<std::vector<long long>>;",
			"",
			"#define F            first",
			"#define S            second",
			"#define mp           std::make_pair",
			"#define rep(i, a, b) for (int i = (a); i < (b); i++)",
			"#define per(i, b, a) for (int i = (b); i > (a); i--)",
			"#define all(x)       (x).begin(), (x).end()",
			"",
			"using namespace std;",
			"",
			"constexpr int h = 1000000007;",
			"",
			"signed main() {",
			"#ifndef LOCAL",
			"\tcin.tie(nullptr);",
			"\tcerr.setstate(ios::failbit);",
			"#endif",
			"\tios::sync_with_stdio(false);",
			"\t",
			"\t$0",
			"}",
			""
		],
		"description": "Shubham Avasthi's C++ template for Competitive Programming"
	},


	"Sparse Table": {
		"prefix": "sparse-table",
		"body": [
			"template <class T>",
			"class SparseTable {",
			"private:",
			"\tstd::vector<int> const logs;",
			"\tstd::vector<std::vector<T>> const sp;",
			"",
			"\tT merge(T const&, T const&) const;",
			"",
			"\tstd::vector<int> compute_logs(int const size) const {",
			"\t\tstd::vector<int> logs(size + 1);",
			"\t\tfor (int i = 2; i <= size; i++) {",
			"\t\t\tlogs[i] = logs[i / 2] + 1;",
			"\t\t}",
			"\t\treturn logs;",
			"\t}",
			"",
			"\tstd::vector<std::vector<T>> compute_sp(std::vector<T> const& arr) const {",
			"\t\tstd::vector<std::vector<T>> sp(logs.back() + 1);",
			"\t\tsp[0] = arr;",
			"\t\tfor (int p = 1; p < sp.size(); p++) {",
			"\t\t\tsp[p].resize(arr.size() + 1 - (1 << p));",
			"\t\t\tfor (int i = 0; i < sp[p].size(); i++) {",
			"\t\t\t\tsp[p][i] = merge(sp[p - 1][i], sp[p - 1][i + (1 << (p - 1))]);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn sp;",
			"\t}",
			"",
			"public:",
			"\tSparseTable(std::vector<T> const& arr) : logs(compute_logs(arr.size())), sp(compute_sp(arr)) {}",
			"",
			"\tT query(int const start, int const end) const {",
			"\t\tif (end < start or start < 0 or end > sp[0].size()) {",
			"\t\t\tthrow std::invalid_argument(std::string(__func__) + \"(start = \" + std::to_string(start) + \", end = \" + std::to_string(end) + \")\");",
			"\t\t}",
			"\t\tint const p = logs[end - start];",
			"\t\treturn merge(sp[p][start], sp[p][end - (1 << p)]);",
			"\t}",
			"};",
			"",
			"// Modify as required",
			"",
			"template <class T>",
			"T SparseTable<T>::merge(T const& val1, T const& val2) const {",
			"\treturn std::max(val1, val2);",
			"}"
		],
		"description": "Sparse Table"
	},


	"Suffix Array": {
		"prefix": "suffix-array",
		"body": [
			"template <class T>",
			"class SparseTable {",
			"private:",
			"\tstd::vector<int> const logs;",
			"\tstd::vector<std::vector<T>> const sp;",
			"",
			"\tT merge(T const&, T const&) const;",
			"",
			"\tstd::vector<int> compute_logs(int const size) const {",
			"\t\tstd::vector<int> logs(size + 1);",
			"\t\tfor (int i = 2; i <= size; i++) {",
			"\t\t\tlogs[i] = logs[i / 2] + 1;",
			"\t\t}",
			"\t\treturn logs;",
			"\t}",
			"",
			"\tstd::vector<std::vector<T>> compute_sp(std::vector<T> const& arr) const {",
			"\t\tstd::vector<std::vector<T>> sp(logs.back() + 1);",
			"\t\tsp[0] = arr;",
			"\t\tfor (int p = 1; p < sp.size(); p++) {",
			"\t\t\tsp[p].resize(arr.size() + 1 - (1 << p));",
			"\t\t\tfor (int i = 0; i < sp[p].size(); i++) {",
			"\t\t\t\tsp[p][i] = merge(sp[p - 1][i], sp[p - 1][i + (1 << (p - 1))]);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn sp;",
			"\t}",
			"",
			"public:",
			"\tSparseTable(std::vector<T> const& arr) : logs(compute_logs(arr.size())), sp(compute_sp(arr)) {}",
			"",
			"\tT query(int const start, int const end) const {",
			"\t\tif (end < start or start < 0 or end > sp[0].size()) {",
			"\t\t\tthrow std::invalid_argument(std::string(__func__) + \"(start = \" + std::to_string(start) + \", end = \" + std::to_string(end) + \")\");",
			"\t\t}",
			"\t\tint const p = logs[end - start];",
			"\t\treturn merge(sp[p][start], sp[p][end - (1 << p)]);",
			"\t}",
			"};",
			"",
			"// Modify as required",
			"",
			"template <class T>",
			"T SparseTable<T>::merge(T const& val1, T const& val2) const {",
			"\treturn std::min(val1, val2);",
			"}",
			"",
			"class SuffixArray {",
			"private:",
			"\tstruct SuffixArrayData {",
			"\t\tstd::vector<int> suffix_array;",
			"\t\tstd::vector<int> ranks;",
			"\t};",
			"",
			"\tstd::string const str;",
			"\tstd::optional<std::vector<int>> lcps_;",
			"\tstd::optional<SparseTable<int>> lcps_spt;",
			"",
			"\tSuffixArrayData compute_suffix_array(std::string const& s) const {",
			"\t\tstd::vector<int> ordering(s.size());",
			"\t\tstd::iota(ordering.begin(), ordering.end(), 0);",
			"\t\tstd::sort(ordering.begin(), ordering.end(),",
			"\t\t\t[&s](int const ind1, int const ind2) {",
			"\t\t\t\treturn s[ind1] < s[ind2];",
			"\t\t\t}",
			"\t\t);",
			"\t\tstd::vector<int> ranks(s.size());",
			"\t\tfor (int i = 1; i < ordering.size(); i++) {",
			"\t\t\tranks[ordering[i]] = ranks[ordering[i - 1]] + (s[ordering[i - 1]] != s[ordering[i]]);",
			"\t\t}",
			"\t\tint len = 1;",
			"\t\twhile(len < s.size()) {",
			"\t\t\tstd::vector<int> pos(s.size());",
			"\t\t\tfor (int i = 0; i < s.size(); i++) {",
			"\t\t\t\tpos[ranks[i]]++;",
			"\t\t\t}",
			"\t\t\tint sum = 0;",
			"\t\t\tfor (int i = 0; i < s.size(); i++) {",
			"\t\t\t\tsum += pos[i];",
			"\t\t\t\tpos[i] = sum - pos[i];",
			"\t\t\t}",
			"\t\t\tstd::vector<int> new_ordering(s.size());",
			"\t\t\tfor (int const& ind2 : ordering) {",
			"\t\t\t\tint const ind1 = (ind2 - len + s.size()) % s.size();",
			"\t\t\t\tnew_ordering[pos[ranks[ind1]]++] = ind1;",
			"\t\t\t}",
			"\t\t\tordering = std::move(new_ordering);",
			"\t\t\tstd::vector<int> new_ranks(s.size());",
			"\t\t\tfor (int i = 1; i < ordering.size(); i++) {",
			"\t\t\t\tnew_ranks[ordering[i]] = new_ranks[ordering[i - 1]] + (ranks[ordering[i - 1]] != ranks[ordering[i]]",
			"\t\t\t\t\tor ranks[(ordering[i - 1] + len) % s.size()] != ranks[(ordering[i] + len) % s.size()]);",
			"\t\t\t}",
			"\t\t\tranks = std::move(new_ranks);",
			"\t\t\tlen *= 2;",
			"\t\t}",
			"\t\treturn {ordering, ranks};",
			"\t}",
			"",
			"\tSuffixArray(std::string const& s_plus_small_char, SuffixArrayData const& data) : str(s_plus_small_char), suffix_array(data.suffix_array), ranks(data.ranks) {}",
			"",
			"public:",
			"\tstd::vector<int> const suffix_array, ranks;",
			"",
			"\tSuffixArray(std::string const& s) : SuffixArray(s + char(0), compute_suffix_array(s + char(0))) {}",
			"",
			"\tint num_occurences(std::string const& s) const {",
			"\t\tstd::vector<int>::const_iterator const start = std::lower_bound(suffix_array.begin(), suffix_array.end(), s,",
			"\t\t\t[this](int const ind, std::string const& s) {",
			"\t\t\t\treturn str.substr(ind, s.size()) < s;",
			"\t\t\t}",
			"\t\t);",
			"\t\tstd::vector<int>::const_iterator const end = std::upper_bound(suffix_array.begin(), suffix_array.end(), s,",
			"\t\t\t[this](std::string const& s, int const ind) {",
			"\t\t\t\treturn s < str.substr(ind, s.size());",
			"\t\t\t}",
			"\t\t);",
			"\t\treturn end - start;",
			"\t}",
			"",
			"\tstd::vector<int> const& lcps() {",
			"\t\tif (not lcps_) {",
			"\t\t\tlcps_.emplace(str.size() - 1);",
			"\t\t\tint match = 0;",
			"\t\t\tfor (int i = 0; i < str.size() - 1; i++) {",
			"\t\t\t\tint const p = suffix_array[ranks[i] - 1];",
			"\t\t\t\twhile (str[p + match] == str[i + match]) {",
			"\t\t\t\t\tmatch++;",
			"\t\t\t\t}",
			"\t\t\t\tlcps_.value()[ranks[i] - 1] = match;",
			"\t\t\t\tmatch = std::max(match - 1, 0);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn *lcps_;",
			"\t}",
			"",
			"\tint lcp(int const ind1, int const ind2) {",
			"\t\tif (ind1 < 0 or ind1 >= str.size() - 1 or ind2 < 0 or ind2 >= str.size() - 1) {",
			"\t\t\tthrow std::invalid_argument(std::string(__func__)",
			"\t\t\t\t+ \"(ind1 = \" + std::to_string(ind1) + \", ind2 = \" + std::to_string(ind2) + \")\");",
			"\t\t}",
			"\t\tif (ind1 == ind2) {",
			"\t\t\treturn str.size() - 1 - ind1;",
			"\t\t}",
			"\t\tif (not lcps_spt) {",
			"\t\t\tlcps_spt.emplace(lcps());",
			"\t\t}",
			"\t\tint r1 = ranks[ind1];",
			"\t\tint r2 = ranks[ind2];",
			"\t\tif (r1 > r2) {",
			"\t\t\tstd::swap(r1, r2);",
			"\t\t}",
			"\t\treturn lcps_spt->query(r1, r2);",
			"\t}",
			"",
			"\tint compare(int const sub1_start, int const sub1_end, int const sub2_start, int const sub2_end) {",
			"\t\tif (sub1_end < sub1_start or sub1_start < 0 or sub1_end >= str.size()",
			"\t\t\tor sub2_end < sub2_start or sub2_start < 0 or sub2_end >= str.size()) {",
			"\t\t\tthrow std::invalid_argument(std::string(__func__)",
			"\t\t\t\t+ \"(sub1_start = \" + std::to_string(sub1_start) + \", sub1_end = \" + std::to_string(sub1_end)",
			"\t\t\t\t+ \", sub2_start = \" + std::to_string(sub2_start) + \", sub2_end = \" + std::to_string(sub2_end) + \")\");",
			"\t\t}",
			"\t\tint const len1 = sub1_end - sub1_start;",
			"\t\tint const len2 = sub2_end - sub2_start;",
			"\t\tif (lcp(sub1_start, sub2_start) < std::min(len1, len2)) {",
			"\t\t\treturn ranks[sub1_start] < ranks[sub2_start] ? -1 : 1;",
			"\t\t}",
			"\t\treturn len1 == len2 ? 0 : (len1 < len2 ? -1 : 1);",
			"\t}",
			"};"
		],
		"description": "Suffix Array"
	}
}
