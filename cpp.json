{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	
	"My Template for Competitive Programming": {
		"prefix": "mytemplate",
		"body": [
			"#include <algorithm>",
			"#include <array>",
			"#include <bitset>",
			"#include <cassert>",
			"#include <cfloat>",
			"#include <chrono>",
			"#include <climits>",
			"#include <cmath>",
			"#include <cstdio>",
			"#include <deque>",
			"#include <iomanip>",
			"#include <iostream>",
			"#include <map>",
			"#include <numeric>",
			"#include <queue>",
			"#include <random>",
			"#include <set>",
			"#include <sstream>",
			"#include <stack>",
			"#include <stdexcept>",
			"#include <unordered_map>",
			"#include <unordered_set>",
			"#include <vector>",
			"using namespace std;",
			"",
			"template <class T1, class T2>",
			"ostream& operator << (ostream& out, const pair <T1, T2> p)",
			"{",
			"\tout << '(' << p.first << ',' << p.second << ')';",
			"\treturn out;",
			"}",
			"",
			"template <class T1, class T2>",
			"istream& operator >> (istream& in, pair<T1, T2> &p)",
			"{",
			"\tin >> p.first >> p.second;",
			"\treturn in;",
			"}",
			"",
			"template <class T>",
			"istream& operator >> (istream& in, vector<T> &v)",
			"{",
			"\tfor (T &x : v)",
			"\t\tin >> x;",
			"\treturn in;",
			"}",
			"",
			"template <class T>",
			"ostream& operator << (ostream& out, const vector<vector<T>> &v)",
			"{",
			"\tfor (const vector<T> &x : v)",
			"\t\tout << x << '\\n';",
			"\treturn out;",
			"}",
			"",
			"template <class T>",
			"ostream& operator << (ostream& out, const vector<T> &v)",
			"{",
			"\tfor (const T &x : v)",
			"\t\tout << x << ' ';",
			"\treturn out;",
			"}",
			"",
			"long long gcd (long long a, long long b)",
			"{",
			"\tif (b > a)",
			"\t\tswap(a, b);",
			"\treturn (b ? gcd(b, a % b) : a);",
			"}",
			"",
			"using ll   = long long;",
			"using pii  = pair<int, int>;",
			"using pll  = pair<long long, long long>;",
			"using tiii = pair<pair<int, int>, int>;",
			"using vi   = vector<int>;",
			"using vl   = vector<long long>;",
			"using vvi  = vector<vector<int>>;",
			"using vvl  = vector<vector<long long>>;",
			"",
			"#define F          first",
			"#define S          second",
			"#define First      first.first",
			"#define Second     first.second",
			"#define Third      second",
			"#define mp         make_pair",
			"#define rep(i,a,b) for (int i = (a); i < (b); i++)",
			"#define per(i,b,a) for (int i = (b); i > (a); i--)",
			"#define all(x)     x.begin(), x.end()",
			"#define ret(x)     return cout << x, 0;",
			"#define throwex    throw runtime_error (\"Found the error.\");",
			"",
			"const int h = 1000000007;",
			"",
			"signed main()",
			"{",
			"\tios::sync_with_stdio(false);",
			"\t#ifdef ONLINE_JUDGE",
			"\tcin.tie(nullptr);",
			"\tcout.tie(nullptr);",
			"\tcerr.setstate(ios::failbit);",
			"\t#endif",
			"",
			"\t$0",
			"}",
			""
		],
		"description": "Inserts my C++ template for Competitive Programming"
	},


	"Segment Tree": {
		"prefix": "segment-tree",
		"body": [
			"template <class T = long long>",
			"class SegTree",
			"{",
			"private:",
			"\tT default_element_value = 0;",
			"\tvector<T> v, seg_tree;",
			"\tT merge(T x, T y)",
			"\t{",
			"\t\treturn max(x, y);",
			"\t}",
			"\tvoid build(int node, int start, int end)",
			"\t{",
			"\t\tif(start == end)",
			"\t\t\tseg_tree[node] = v[start];",
			"\t\telse",
			"\t\t{",
			"\t\t\tbuild(2*node+1, start, (start+end)/2);",
			"\t\t\tbuild(2*node+2, (start+end)/2+1, end);",
			"\t\t\tseg_tree[node] = merge(seg_tree[2*node+1], seg_tree[2*node+2]);",
			"\t\t}",
			"\t}",
			"\tvoid update(int node, int start, int end, int index, T val)",
			"\t{",
			"\t\tif(start == end)",
			"\t\t{",
			"\t\t\tseg_tree[node] = val;",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tif(index<=(start+end)/2)",
			"\t\t\tupdate(2*node+1, start, (start+end)/2, index, val);",
			"\t\telse",
			"\t\t\tupdate(2*node+2, (start+end)/2+1, end, index, val);",
			"\t\tseg_tree[node] = merge(seg_tree[2*node+1], seg_tree[2*node+2]);",
			"\t}",
			"\tT query(int node, int start, int end, int l, int r)",
			"\t{",
			"\t\tif(end<l || start>r)",
			"\t\t\treturn default_element_value;",
			"\t\tif(start>=l && end<=r)",
			"\t\t\treturn seg_tree[node];",
			"\t\treturn merge(",
			"\t\t\tquery(2*node+1, start, (start+end)/2, l, r),",
			"\t\t\tquery(2*node+2, (start+end)/2+1, end, l, r));",
			"\t}",
			"",
			"public:",
			"\tSegTree(int n)",
			"\t{",
			"\t\tv.resize(n, default_element_value); //except its size, v won't be used anymore",
			"\t\tseg_tree.resize(4 * n, default_element_value);",
			"\t}",
			"\tSegTree(vector<T> &arr)",
			"\t{",
			"\t\tv = arr;",
			"\t\tseg_tree.resize(4 * v.size(), default_element_value);",
			"\t\tbuild(0, 0, v.size()-1);",
			"\t}",
			"\tvoid update(int index, T val)",
			"\t{",
			"\t\tupdate(0, 0, v.size()-1, index, val);",
			"\t}",
			"\tT query(int l, int r)",
			"\t{",
			"\t\treturn query(0, 0, v.size()-1, l, r);",
			"\t}",
			"};"
		],
		"description": "My segment tree code"
	},


	"Disjoint Set Union": {
		"prefix": "disjoint_set_union",
		"body": [
			"class Dsu",
			"{",
			"private:",
			"\tvector<int> par, size;",
			"\tint distinct_sets_count;",
			"",
			"public:",
			"\tDsu(int n)",
			"\t{",
			"\t\tdistinct_sets_count = n;",
			"\t\tpar.resize(n);",
			"\t\tfor(int i = 0; i < n; i++)",
			"\t\t\tpar[i] = i;",
			"\t\tsize.resize(n, 1);",
			"\t}",
			"",
			"\tint root(int x)",
			"\t{",
			"\t\tif(par[x] == x)",
			"\t\t\treturn x;",
			"\t\treturn par[x] = root(par[x]);",
			"\t}",
			"",
			"\tvoid connect(int a, int b)",
			"\t{",
			"\t\ta = root(a), b = root(b);",
			"\t\tif(a == b) return;",
			"\t\tif(size[a] < size[b])",
			"\t\t\tswap(a, b);",
			"\t\tsize[a] += size[b];",
			"\t\tpar[b] = a;",
			"\t\tdistinct_sets_count--;",
			"\t}",
			"",
			"\tint set_count()",
			"\t{",
			"\t\treturn distinct_sets_count;",
			"\t}",
			"};"
		],
		"description": "My Disjoint Set Union class"
	},


	"Euler's Totient function": {
		"prefix": "totient",
		"body": [
			"long long phi(long long n)",
			"{",
			"\tlong long ans = n;",
			"\tfor(long long i = 2; i * i <= n; i++)",
			"\t\tif(n % i == 0)",
			"\t\t{",
			"\t\t\tans -= ans / i;",
			"\t\t\twhile(n % i == 0)",
			"\t\t\t\tn /= i;",
			"\t\t}",
			"\tif(n > 1)",
			"\t\tans -= ans / n;",
			"\treturn ans;",
			"}"
		],
		"description": "My Euler's Totient function code"
	},


	"Manacher's Algorithm": {
		"prefix": "manacher",
		"body": [
			"class Manacher",
			"{",
			"\tpublic:",
			"\tvector<int> d1, d2;",
			"",
			"\tManacher (string s)",
			"\t{",
			"\t\td1.resize(s.size());",
			"\t\td2.resize(s.size() - 1);",
			"\t\tfor (int i = 0, l = -1, r = -1; i < s.size(); i++)",
			"\t\t{",
			"\t\t\tint k = (i > r) ? 0 : min(d1[l + r - i], r - i + 1);",
			"\t\t\twhile (i - k > - 1 and i + k < s.size() and s[i - k] == s[i + k])",
			"\t\t\t\tk++;",
			"\t\t\td1[i] = k;",
			"\t\t\tif (i + d1[i] - 1 > r)",
			"\t\t\t{",
			"\t\t\t\tl = i - d1[i] + 1;",
			"\t\t\t\tr = i + d1[i] - 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor (int i = 0, l = -1, r = -1; i < s.size() - 1; i++)",
			"\t\t{",
			"\t\t\tint k = (i > r - 1) ? 0 : min(d2[l + r - i - 1], r - i);",
			"\t\t\twhile (i - k > - 1 and i + 1 + k < s.size() and s[i - k] == s[i + 1 + k])",
			"\t\t\t\tk++;",
			"\t\t\td2[i] = k;",
			"\t\t\tif (i + d2[i] > r)",
			"\t\t\t{",
			"\t\t\t\tl = i - d2[i] + 1;",
			"\t\t\t\tr = i + d2[i];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"};",
			""
		],
		"description": "My Manacher's Algorithm's code"
	},


	"Lowest Common Ancestor": {
		"prefix": "lowest-common-ancestor",
		"body": [
			"class LCA",
			"{",
			"private:",
			"\tstatic const int max_power_of_2 = 24;",
			"\tvector<int> par, level;",
			"\tarray<vector<int>, max_power_of_2 + 1> sp;",
			"",
			"\tint lift (int x, int d)",
			"\t{",
			"\t\tfor (int i = max_power_of_2; i > -1; i--)",
			"\t\t\tif(d >= 1 << i)",
			"\t\t\t{",
			"\t\t\t\td -= 1 << i;",
			"\t\t\t\tx = sp[i][x];",
			"\t\t\t}",
			"\t\treturn x;",
			"\t}",
			"",
			"\tvoid dfs (int x, int p, int lev, vector<vector<int>> &M)",
			"\t{",
			"\t\tpar[x] = p;",
			"\t\tlevel[x] = lev;",
			"\t\tfor(int y : M[x])",
			"\t\t{",
			"\t\t\tif(par[y] != -1) continue;",
			"\t\t\tdfs(y, x, lev + 1, M);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tLCA (vector<vector<int>> &M)",
			"\t{",
			"\t\tpar.resize(M.size(), -1);",
			"\t\tlevel.resize(M.size());",
			"\t\tfor(vector<int> &x : sp)",
			"\t\t\tx.resize(M.size());",
			"\t\tdfs(0, 0, 0, M);",
			"\t\tsp[0] = par;",
			"\t\tfor (int i = 1; i < max_power_of_2 + 1; i++)",
			"\t\t\tfor (int j = 0; j < M.size(); j++)",
			"\t\t\t\tsp[i][j] = sp[i-1][sp[i-1][j]];",
			"\t}",
			"",
			"\tint dist (int x, int y)",
			"\t{",
			"\t\tif(level[x] < level[y])",
			"\t\t\tswap(x, y);",
			"\t\tint ans = level[x] - level[y];",
			"\t\tx = lift(x, level[x] - level[y]);",
			"\t\tfor (int i = max_power_of_2; i > -1; i--)",
			"\t\t\tif (sp[i][x] != sp[i][y])",
			"\t\t\t{",
			"\t\t\t\tx = sp[i][x];",
			"\t\t\t\ty = sp[i][y];",
			"\t\t\t\tans += 2 * (1 << i);",
			"\t\t\t}",
			"\t\treturn ans + 2 * (x != y);",
			"\t}",
			"};"
		],
		"description": "My Lowest Common Ancestor code"
	},


	"Binary Lifting": {
		"prefix": "binary-lifting",
		"body": [
			"class BinaryLifting",
			"{",
			"private:",
			"\tstatic const int max_power_of_2 = 24;",
			"\tarray<vector<int>, max_power_of_2 + 1> sp;",
			"",
			"\tvoid dfs (int x, int p, int lev, vector<vector<int>> &M)",
			"\t{",
			"\t\tsp[0][x] = p;",
			"\t\tfor(int y : M[x])",
			"\t\t{",
			"\t\t\tif(sp[0][y] != -1) continue;",
			"\t\t\tdfs(y, x, lev + 1, M);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tBinaryLifting (vector<vector<int>> &M)",
			"\t{",
			"\t\tfor(vector<int> &x : sp)",
			"\t\t\tx.resize(M.size(), -1);",
			"\t\tdfs(0, 0, 0, M);",
			"\t\tfor (int i = 1; i <= max_power_of_2; i++)",
			"\t\t\tfor (int j = 0; j < M.size(); j++)",
			"\t\t\t\tsp[i][j] = sp[i-1][sp[i-1][j]];",
			"\t}",
			"",
			"\tint lift (int x, int d)",
			"\t{",
			"\t\tfor (int i = max_power_of_2; i > -1; i--)",
			"\t\t\tif(d >= 1 << i)",
			"\t\t\t{",
			"\t\t\t\td -= 1 << i;",
			"\t\t\t\tx = sp[i][x];",
			"\t\t\t}",
			"\t\treturn x;",
			"\t}",
			"};"
		],
		"description": "My binary lifting code"
	},


	"Time it": {
		"prefix": "time-it",
		"body": [
			"auto start_time = chrono::high_resolution_clock::now();",
			"",
			"auto end_time = chrono::high_resolution_clock::now();",
			"chrono::high_resolution_clock::duration time_duration = end_time - start_time;",
			"",
			"auto h  = chrono::duration_cast<chrono::hours>(time_duration);        time_duration -= h;",
			"auto m  = chrono::duration_cast<chrono::minutes>(time_duration);      time_duration -= m;",
			"auto s  = chrono::duration_cast<chrono::seconds>(time_duration);      time_duration -= s;",
			"auto ms = chrono::duration_cast<chrono::milliseconds>(time_duration); time_duration -= ms;",
			"auto us = chrono::duration_cast<chrono::microseconds>(time_duration); time_duration -= us;",
			"auto ns = chrono::duration_cast<chrono::nanoseconds>(time_duration);",
			"",
			"cerr<<\"Execution Time: \"",
			"<< h.count()  << \" hours \"",
			"<< m.count()  << \" minutes \"",
			"<< s.count()  << \" seconds \"",
			"<< ms.count() << \" milliseconds \"",
			"<< us.count() << \" microseconds \"",
			"<< ns.count() << \" nanoseconds\\n\";"
		],
		"description": "Code to print the execution time of a section of code"
	},


	"Fast Walsh Hadamard Transform": {
		"prefix": "fast-walsh-hadamard-transform",
		"body": [
			"class FWHT",
			"{",
			"private:",
			"\tstatic const int mod = 1000000007;",
			"",
			"\tstatic long long p (long long x, long long y)",
			"\t{",
			"\t\tif (y == 0) return 1;",
			"\t\tlong long z = p (x, y / 2);",
			"\t\tz *= z;",
			"\t\tz %= mod;",
			"\t\treturn (y & 1 ? (z * x) % mod : z);",
			"\t}",
			"",
			"\tstatic long long inv (long long x)",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"",
			"public:",
			"\tstatic void fwht (vector<int> & a, bool invert) {",
			"\t\tint n = a.size();",
			"\t\tfor (int len = 1; 2 * len <= n; len <<= 1) {",
			"\t\t\tfor (int i = 0; i < n; i += 2 * len) {",
			"\t\t\t\tfor (int j = 0; j < len; j++) {",
			"\t\t\t\t\tint u = a[i + j];",
			"\t\t\t\t\tint v = a[i + j + len];",
			"\t\t\t\t\ta[i + j] = u + v < mod ? u + v : u + v - mod;",
			"\t\t\t\t\ta[i + j + len] = u - v >= 0 ? u - v : u - v + mod;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (invert) {",
			"\t\t\tint n_1 = inv(n);",
			"\t\t\tfor (int & x : a)",
			"\t\t\t\tx = (int)(1LL * x * n_1 % mod);",
			"\t\t}",
			"\t}",
			"\t",
			"\tstatic vector<int> multiply(vector<int> const& a, vector<int> const& b) {",
			"\t\tvector<int> fa(a), fb(b);",
			"\t\tint n = 1;",
			"\t\twhile (n < a.size() or n < b.size()) ",
			"\t\t\tn <<= 1;",
			"\t\tfa.resize(n);",
			"\t\tfb.resize(n);",
			"",
			"\t\tfwht(fa, false);",
			"\t\tfwht(fb, false);",
			"\t\tfor (int i = 0; i < n; i++)",
			"\t\t\tfa[i] = (1LL * fa[i] * fb[i] % mod);",
			"\t\tfwht(fa, true);",
			"",
			"\t\treturn fa;",
			"\t}",
			"};"
		],
		"description": "My Fast Walsh Hadamard Transform code."
	},


	"Segment Tree with Lazy Propagation": {
		"prefix": "segment-tree-with-lazy-propagation",
		"body": [
			"template <class elem_T = long long, class upd_T = long long>",
			"class SegTree",
			"{",
			"\tprivate:",
			"\t\tconst int underlying_array_size;",
			"\t\tconst elem_T merge_identity = {{0, 0}, 0};",
			"\t\tconst upd_T update_identity = 0;",
			"\t\telem_T merge(const elem_T x, const elem_T y)",
			"\t\t{",
			"\t\t\treturn max(x, y);",
			"\t\t}",
			"\t\telem_T update_elem(const elem_T x, const upd_T y)",
			"\t\t{",
			"\t\t\treturn x + y;",
			"\t\t}",
			"\t\tupd_T update_lazy(const upd_T x, const upd_T y)",
			"\t\t{",
			"\t\t\treturn x + y;",
			"\t\t}",
			"\t\tvector<elem_T> seg_tree;",
			"\t\tvector<upd_T> lazy;",
			"\t\tvoid build(int node, int start, int end, vector<elem_T> &v)",
			"\t\t{",
			"\t\t\tif(start == end)",
			"\t\t\t\tseg_tree[node] = v[start];",
			"\t\t\telse",
			"\t\t\t{",
			"\t\t\t\tconst int mid = (start + end) / 2;",
			"\t\t\t\tbuild(2 * node + 1, start, mid, v);",
			"\t\t\t\tbuild(2 * node + 2, mid + 1, end, v);",
			"\t\t\t\tseg_tree[node] = merge(seg_tree[2 * node + 1], seg_tree[2 * node + 2]);",
			"\t\t\t}",
			"\t\t}",
			"\t\tvoid update_range(int node, int start, int end, int l, int r, upd_T val)",
			"\t\t{",
			"\t\t\tif(l <= start and end <= r)",
			"\t\t\t\tlazy[node] = update_lazy(lazy[node], val);",
			"\t\t\tif(lazy[node] != update_identity)",
			"\t\t\t{",
			"\t\t\t\tif(start != end)",
			"\t\t\t\t{",
			"\t\t\t\t\tlazy[2 * node + 1] = update_lazy(lazy[2 * node + 1], lazy[node]);",
			"\t\t\t\t\tlazy[2 * node + 2] = update_lazy(lazy[2 * node + 2], lazy[node]);",
			"\t\t\t\t}",
			"\t\t\t\tseg_tree[node] = update_elem(seg_tree[node], lazy[node]);",
			"\t\t\t\tlazy[node] = update_identity;",
			"\t\t\t}",
			"\t\t\tif(end < l or start > r)",
			"\t\t\t\treturn;",
			"\t\t\tif(l <= start and end <= r)",
			"\t\t\t\treturn;",
			"\t\t\tconst int mid = (start + end) / 2;",
			"\t\t\tupdate_range(2 * node + 1, start, mid, l, r, val);",
			"\t\t\tupdate_range(2 * node + 2, mid + 1, end, l, r, val);",
			"\t\t\tseg_tree[node] = merge(seg_tree[2 * node + 1], seg_tree[2 * node + 2]);",
			"\t\t}",
			"\t\telem_T query(int node, int start, int end, int l, int r)",
			"\t\t{",
			"\t\t\tif(end < l or start > r)",
			"\t\t\t\treturn merge_identity;",
			"\t\t\tif(lazy[node] != update_identity)",
			"\t\t\t{",
			"\t\t\t\tif(start != end)",
			"\t\t\t\t{",
			"\t\t\t\t\tlazy[2 * node + 1] = update_lazy(lazy[2 * node + 1], lazy[node]);",
			"\t\t\t\t\tlazy[2 * node + 2] = update_lazy(lazy[2 * node + 2], lazy[node]);",
			"\t\t\t\t}",
			"\t\t\t\tseg_tree[node] = update_elem(seg_tree[node], lazy[node]);",
			"\t\t\t\tlazy[node] = update_identity;",
			"\t\t\t}",
			"\t\t\tif(l <= start and end <= r)",
			"\t\t\t\treturn seg_tree[node];",
			"\t\t\tconst int mid = (start + end) / 2;",
			"\t\t\treturn merge(",
			"\t\t\t\tquery(2 * node + 1, start, mid, l, r),",
			"\t\t\t\tquery(2 * node + 2, mid + 1, end, l, r));",
			"\t\t}",
			"",
			"\tpublic:",
			"\t\tSegTree(const int n) : underlying_array_size(n)",
			"\t\t{",
			"\t\t\tvector<elem_T> v(underlying_array_size, merge_identity);",
			"\t\t\tseg_tree.resize(4 * underlying_array_size, merge_identity);",
			"\t\t\tlazy.resize(4 * underlying_array_size, update_identity);",
			"\t\t\tbuild(0, 0, underlying_array_size - 1, v);",
			"\t\t}",
			"\t\tSegTree(vector<elem_T> &v) : underlying_array_size(v.size())",
			"\t\t{",
			"\t\t\tseg_tree.resize(4 * underlying_array_size, merge_identity);",
			"\t\t\tlazy.resize(4 * underlying_array_size, update_identity);",
			"\t\t\tbuild(0, 0, underlying_array_size - 1, v);",
			"\t\t}",
			"\t\tvoid update_range(int l, int r, upd_T val)",
			"\t\t{",
			"\t\t\tupdate_range(0, 0, underlying_array_size - 1, l, r, val);",
			"\t\t}",
			"\t\telem_T query(int l, int r)",
			"\t\t{",
			"\t\t\treturn query(0, 0, underlying_array_size - 1, l, r);",
			"\t\t}",
			"};"
		],
		"description": "My code for a segment tree with lazy propagation."
	},


	"Number Theoretic Transform": {
		"prefix": "number-theoretic-transform",
		"body": [
			"class NTT",
			"{",
			"private:",
			"\tstatic const int mod = 998244353;    // 2^k * c + 1 (998244353 == 2^23 * 7 * 17 + 1)",
			"",
			"\t// Automatic finding of primitive root and nth root of unity currently works only for prime modules of the form 2^k * c + 1",
			"\t",
			"\tstatic const int primitive_root; // g",
			"\tstatic const int root;           // g^c modulo mod",
			"\tstatic const int root_1;         // root^-1 modulo mod",
			"\tstatic const int root_pw;        // 2^k",
			"",
			"\tstatic constexpr long long p (long long x, long long y)",
			"\t{",
			"\t\tlong long ans = 1;",
			"\t\twhile(y)",
			"\t\t{",
			"\t\t\tif(y & 1)",
			"\t\t\t\t(ans *= x) %= mod;",
			"\t\t\t(x *= x) %= mod;",
			"\t\t\ty /= 2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tstatic constexpr long long inv (long long x)",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"",
			"\tstatic constexpr int get_primitive_root()",
			"\t{",
			"\t\tconst int phi = mod - 1;",
			"\t\tint x = phi;",
			"\t\tint powers_to_be_checked[32] = {};",
			"\t\tint powers_to_be_checked_size = 0;",
			"\t\tfor(int i = 2; i * i <= x; i++)",
			"\t\t{",
			"\t\t\tpowers_to_be_checked[powers_to_be_checked_size] = phi / i;",
			"\t\t\tpowers_to_be_checked_size++;",
			"\t\t\twhile(x % i == 0)",
			"\t\t\t\tx /= i;",
			"\t\t}",
			"\t\tint num = 1;",
			"\t\tbool ok = false;",
			"\t\tdo",
			"\t\t{",
			"\t\t\tnum++;",
			"\t\t\tok = true;",
			"\t\t\tfor(int i = 0; i < powers_to_be_checked_size; i++)",
			"\t\t\t\tif(p(num, powers_to_be_checked[i]) == 1)",
			"\t\t\t\t{",
			"\t\t\t\t\tok = false;",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"\t\t} while(!ok);",
			"\t\treturn num;",
			"\t}",
			"",
			"\tstatic constexpr int get_root()",
			"\t{",
			"\t\tint c = mod - 1;",
			"\t\twhile(!(c & 1))",
			"\t\t\tc /= 2;",
			"\t\t// Cannot use primitive_root here directly, Codechef does not allow it.",
			"\t\t// Works on my local machine though.",
			"\t\treturn p(get_primitive_root(), c);",
			"\t}",
			"",
			"\tstatic constexpr int get_root_pw()",
			"\t{",
			"\t\tint two_k = 1, n = mod - 1;",
			"\t\twhile(!(n & 1))",
			"\t\t\ttwo_k *= 2, n /= 2;",
			"\t\treturn two_k;",
			"\t}",
			"",
			"\tstatic void ntt (vector<int> & a, bool invert)",
			"\t{",
			"\t\tint n = a.size();",
			"",
			"\t\tfor (int i = 1, j = 0; i < n; i++) {",
			"\t\t\tint bit = n >> 1;",
			"\t\t\tfor (; j & bit; bit >>= 1)",
			"\t\t\t\tj ^= bit;",
			"\t\t\tj ^= bit;",
			"",
			"\t\t\tif (i < j)",
			"\t\t\t\tswap(a[i], a[j]);",
			"\t\t}",
			"",
			"\t\tfor (int len = 2; len <= n; len <<= 1) {",
			"\t\t\tint wlen = invert ? root_1 : root;",
			"\t\t\tfor (int i = len; i < root_pw; i <<= 1)",
			"\t\t\t\twlen = (int)(1LL * wlen * wlen % mod);",
			"",
			"\t\t\tfor (int i = 0; i < n; i += len) {",
			"\t\t\t\tint w = 1;",
			"\t\t\t\tfor (int j = 0; j < len / 2; j++) {",
			"\t\t\t\t\tint u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);",
			"\t\t\t\t\ta[i+j] = u + v < mod ? u + v : u + v - mod;",
			"\t\t\t\t\ta[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;",
			"\t\t\t\t\tw = (int)(1LL * w * wlen % mod);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif (invert) {",
			"\t\t\tint n_1 = inv(n);",
			"\t\t\tfor (int & x : a)",
			"\t\t\t\tx = (int)(1LL * x * n_1 % mod);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tstatic vector<int> multiply(vector<int> const& a, vector<int> const& b) {",
			"\t\tvector<int> fa(a), fb(b);",
			"\t\tint n = 1;",
			"\t\twhile (n < a.size() + b.size()) ",
			"\t\t\tn <<= 1;",
			"\t\tfa.resize(n);",
			"\t\tfb.resize(n);",
			"",
			"\t\tntt(fa, false);",
			"\t\tntt(fb, false);",
			"\t\tfor (int i = 0; i < n; i++)",
			"\t\t\tfa[i] = (1LL * fa[i] * fb[i] % mod);",
			"\t\tntt(fa, true);",
			"\t\treturn fa;",
			"\t}",
			"};",
			"const int NTT::primitive_root = NTT::get_primitive_root();",
			"const int NTT::root = NTT::get_root();",
			"const int NTT::root_1 = NTT::inv(root);",
			"const int NTT::root_pw = NTT::get_root_pw();"
		],
		"description": "My Number Theoretic Transform code"
	},


	"Fast Modular Exponentiation": {
		"prefix": "modexp",
		"body": [
			"namespace modexp",
			"{",
			"\tconst int mod = 1000000007;",
			"",
			"\tconstexpr long long p (long long x, long long y)",
			"\t{",
			"\t\tlong long ans = 1;",
			"\t\twhile(y)",
			"\t\t{",
			"\t\t\tif(y & 1)",
			"\t\t\t\t(ans *= x) %= mod;",
			"\t\t\t(x *= x) %= mod;",
			"\t\t\ty /= 2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\tconstexpr long long inv (const long long x)",
			"\t{",
			"\t\treturn p (x, mod - 2);",
			"\t}",
			"}",
			"using modexp::p;",
			"using modexp::inv;"
		],
		"description": "My fast modular exponentiation code"
	},


	"Gauss Jordan Elimination": {
		"prefix": "gauss-jordan-elimination",
		"body": [
			"class GaussJordanElimination",
			"{",
			"private:",
			"\tstatic constexpr double EPS = 1e-9;",
			"\tvector<double> ans;",
			"\tenum class NumSolutions {unique_solution, no_solution, infinitely_many_solutions} num_solutions = NumSolutions::unique_solution;",
			"",
			"public:",
			"\tGaussJordanElimination(vector<vector<double>> coeffs, vector<double> & vals) : ans(vals)",
			"\t{",
			"\t\tfor(int row = 0; row < coeffs.size(); row++)",
			"\t\t{",
			"\t\t\t// The lambda function is a heuristic to greatly decrease the chances of overflow in later stages of the algorithm",
			"\t\t\tconst int pivot = max_element(",
			"\t\t\t\tcoeffs.begin() + row, coeffs.end(),",
			"\t\t\t\t[row](vector<double> &row1, vector<double> &row2)",
			"\t\t\t\t{return abs(row1[row]) < abs(row2[row]);}",
			"\t\t\t) - coeffs.begin();",
			"",
			"\t\t\tfor(int col = row; col < coeffs[0].size(); col++)",
			"\t\t\t\tswap(coeffs[row][col], coeffs[pivot][col]);",
			"\t\t\tswap(ans[row], ans[pivot]);",
			"",
			"\t\t\tif(abs(coeffs[row][row]) < EPS)",
			"\t\t\t{",
			"\t\t\t\tnum_solutions = NumSolutions::infinitely_many_solutions;",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"",
			"\t\t\tconst double d = coeffs[row][row];",
			"\t\t\tfor(int col = row; col < coeffs[0].size(); col++)",
			"\t\t\t\tcoeffs[row][col] /= d;",
			"\t\t\tans[row] /= d;",
			"",
			"\t\t\tfor(int r = 0; r < coeffs.size(); r++)",
			"\t\t\t{",
			"\t\t\t\tif(r == row)",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\tconst double factor = coeffs[r][row];",
			"\t\t\t\tfor(int c = row; c < coeffs[0].size(); c++)",
			"\t\t\t\t\tcoeffs[r][c] -= coeffs[row][c] * factor;",
			"                ans[r] -= ans[row] * factor;",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif(num_solutions != NumSolutions::unique_solution)",
			"\t\t{",
			"\t\t\tfor(int row = 0; row < coeffs.size(); row++)",
			"\t\t\t\tif(abs(coeffs[row][row]) < EPS and abs(ans[row]) > EPS)",
			"\t\t\t\t{",
			"\t\t\t\t\tnum_solutions = NumSolutions::no_solution;",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tbool has_unique_solution()",
			"\t{",
			"\t\treturn num_solutions == NumSolutions::unique_solution;",
			"\t}",
			"",
			"\tbool has_no_solution()",
			"\t{",
			"\t\treturn num_solutions == NumSolutions::no_solution;",
			"\t}",
			"",
			"\tbool has_infinite_solutions()",
			"\t{",
			"\t\treturn num_solutions == NumSolutions::infinitely_many_solutions;",
			"\t}",
			"",
			"\tconst vector<double> & get_ans()",
			"\t{",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "My code to perform Gauss Jordan Elimination"
	},

	
	"Fenwick Tree": {
		"prefix": "fenwick-tree",
		"body": [
			"template <class T = long long>",
			"class FenwickTree",
			"{",
			"private:",
			"\tvector<T> tree;",
			"\tconst T identity = 0;",
			"\tT merge (const T x, const T y)",
			"\t{",
			"\t\treturn x + y;",
			"\t}",
			"\tT merge_inverse (const T x, const T y)",
			"\t{",
			"\t\treturn x - y;",
			"\t}",
			"\t// index is 0-based",
			"\tT query_0_to_index (int index)",
			"\t{",
			"\t\tT ans = identity;",
			"\t\tindex++;",
			"\t\tfor(; index > 0; index -= index & -index)",
			"\t\t\tans = merge(ans, tree[index]);",
			"\t\treturn ans;",
			"\t}",
			"",
			"public:",
			"\tFenwickTree (const int size)",
			"\t{",
			"\t\ttree.resize(size + 1, identity);",
			"\t}",
			"\t// index is 0-based",
			"\tvoid update (int index, const T delta)",
			"\t{",
			"\t\tindex++;",
			"\t\tfor(; index < tree.size() ; index += index & -index)",
			"\t\t\ttree[index] = merge(tree[index], delta);",
			"\t}",
			"\t// index is 0-based",
			"\tT query (const int l, const int r)",
			"\t{",
			"\t\treturn merge_inverse(query_0_to_index(r), query_0_to_index(l-1));",
			"\t}",
			"};"
		],
		"description": "My Fenwick Tree class"
	}
}